{
    "sourceFile": "pages/components/mintButton.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1731241792388,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731242522581,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,646 @@\n+import {\n+  CandyGuard,\n+  CandyMachine,\n+  mintV2,\n+} from \"@metaplex-foundation/mpl-candy-machine\";\n+import { GuardReturn } from \"../utils/checkerHelper\";\n+import {\n+  AddressLookupTableInput,\n+  KeypairSigner,\n+  PublicKey,\n+  Transaction,\n+  Umi,\n+  createBigInt,\n+  generateSigner,\n+  none,\n+  publicKey,\n+  signAllTransactions,\n+  signTransaction,\n+  sol,\n+  some,\n+  transactionBuilder,\n+} from \"@metaplex-foundation/umi\";\n+import {\n+  DigitalAsset,\n+  DigitalAssetWithToken,\n+  JsonMetadata,\n+  fetchDigitalAsset,\n+  fetchJsonMetadata,\n+} from \"@metaplex-foundation/mpl-token-metadata\";\n+import { mintText } from \"../settings\";\n+import {\n+  Box,\n+  Button,\n+  Flex,\n+  HStack,\n+  Heading,\n+  SimpleGrid,\n+  Text,\n+  Tooltip,\n+  NumberInput,\n+  NumberInputField,\n+  NumberInputStepper,\n+  NumberIncrementStepper,\n+  NumberDecrementStepper,\n+  VStack,\n+  Divider,\n+  createStandaloneToast,\n+} from \"@chakra-ui/react\";\n+import {\n+  fetchAddressLookupTable, setComputeUnitPrice,\n+} from \"@metaplex-foundation/mpl-toolbox\";\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\n+import {\n+  chooseGuardToUse,\n+  routeBuilder,\n+  mintArgsBuilder,\n+  GuardButtonList,\n+  buildTx,\n+  getRequiredCU,\n+} from \"../utils/mintHelper\";\n+import { useSolanaTime } from \"@/utils/SolanaTimeContext\";\n+import { verifyTx } from \"@/utils/verifyTx\";\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\n+\n+const updateLoadingText = (\n+  loadingText: string | undefined,\n+  guardList: GuardReturn[],\n+  label: string,\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\n+) => {\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\n+  if (guardIndex === -1) {\n+    console.error(\"guard not found\");\n+    return;\n+  }\n+  const newGuardList = [...guardList];\n+  newGuardList[guardIndex].loadingText = loadingText;\n+  setGuardList(newGuardList);\n+};\n+\n+const fetchNft = async (\n+  umi: Umi,\n+  nftAdress: PublicKey,\n+) => {\n+  let digitalAsset: DigitalAsset | undefined;\n+  let jsonMetadata: JsonMetadata | undefined;\n+  try {\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\n+  } catch (e) {\n+    console.error(e);\n+    createStandaloneToast().toast({\n+      title: \"Nft could not be fetched!\",\n+      description: \"Please check your Wallet instead.\",\n+      status: \"info\",\n+      duration: 900,\n+      isClosable: true,\n+    });\n+  }\n+\n+  return { digitalAsset, jsonMetadata };\n+};\n+\n+const mintClick = async (\n+  umi: Umi,\n+  guard: GuardReturn,\n+  candyMachine: CandyMachine,\n+  candyGuard: CandyGuard,\n+  ownedTokens: DigitalAssetWithToken[],\n+  mintAmount: number,\n+  mintsCreated:\n+    | {\n+        mint: PublicKey;\n+        offChainMetadata: JsonMetadata | undefined;\n+      }[]\n+    | undefined,\n+  setMintsCreated: Dispatch<\n+    SetStateAction<\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\n+      | undefined\n+    >\n+  >,\n+  guardList: GuardReturn[],\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\n+  onOpen: () => void,\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\n+) => {\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\n+  if (!guardToUse.guards) {\n+    console.error(\"no guard defined!\");\n+    return;\n+  }\n+\n+  let buyBeer = true;\n+  console.log(\"buyBeer\",process.env.NEXT_PUBLIC_BUYMARKBEER )\n+\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER  === \"false\") {\n+    buyBeer = false;\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer ðŸ˜’\");\n+  }\n+\n+  try {\n+    //find the guard by guardToUse.label and set minting to true\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n+    if (guardIndex === -1) {\n+      console.error(\"guard not found\");\n+      return;\n+    }\n+    const newGuardList = [...guardList];\n+    newGuardList[guardIndex].minting = true;\n+    setGuardList(newGuardList);\n+\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\n+    if (routeBuild && routeBuild.items.length > 0) {\n+      createStandaloneToast().toast({\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\n+        status: \"info\",\n+        duration: 900,\n+        isClosable: true,\n+      });\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({commitment: \"finalized\"});\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\n+      const builtTx = await routeBuild.buildAndSign(umi);\n+      const sig = await umi.rpc\n+        .sendTransaction(builtTx, { skipPreflight:true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n+        .then((signature) => {\n+          return { status: \"fulfilled\", value: signature };\n+        })\n+        .catch((error) => {\n+          createStandaloneToast().toast({\n+            title: \"Allow List TX failed!\",\n+            status: \"error\",\n+            duration: 900,\n+            isClosable: true,\n+          });\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\n+\n+        });\n+        if (sig.status === \"fulfilled\")\n+          await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\n+\n+    }\n+\n+    // fetch LUT\n+    let tables: AddressLookupTableInput[] = [];\n+    const lut = process.env.NEXT_PUBLIC_LUT;\n+    if (lut) {\n+      const lutPubKey = publicKey(lut);\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\n+      tables = [fetchedLut];\n+    } else {\n+      createStandaloneToast().toast({\n+        title: \"The developer should really set a lookup table!\",\n+        status: \"warning\",\n+        duration: 900,\n+        isClosable: true,\n+      });\n+    }\n+\n+    const mintTxs: Transaction[] = [];\n+    let nftsigners = [] as KeypairSigner[];\n+\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({commitment: \"finalized\"}));\n+    \n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\n+    const nftMint = generateSigner(umi);\n+    const txForSimulation = buildTx(\n+      umi,\n+      candyMachine,\n+      candyGuard,\n+      nftMint,\n+      guardToUse,\n+      mintArgs,\n+      tables,\n+      latestBlockhash,\n+      1_400_000,\n+      buyBeer\n+    );\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\n+\n+    for (let i = 0; i < mintAmount; i++) {\n+      const nftMint = generateSigner(umi);\n+      nftsigners.push(nftMint);\n+      const transaction = buildTx(\n+        umi,\n+        candyMachine,\n+        candyGuard,\n+        nftMint,\n+        guardToUse,\n+        mintArgs,\n+        tables,\n+        latestBlockhash,\n+        requiredCu,\n+        buyBeer\n+      );\n+      console.log(transaction)\n+      mintTxs.push(transaction);\n+    }\n+    if (!mintTxs.length) {\n+      console.error(\"no mint tx built!\");\n+      return;\n+    }\n+\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\n+    const signedTransactions = await signAllTransactions(\n+      mintTxs.map((transaction, index) => ({\n+        transaction,\n+        signers: [umi.payer, nftsigners[index]],\n+      }))\n+    );\n+\n+    let signatures: Uint8Array[] = [];\n+    let amountSent = 0;\n+    \n+    const sendPromises = signedTransactions.map((tx, index) => {\n+      return umi.rpc\n+        .sendTransaction(tx, { skipPreflight:true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n+        .then((signature) => {\n+          console.log(\n+            `Transaction ${index + 1} resolved with signature: ${\n+              base58.deserialize(signature)[0]\n+            }`\n+          );\n+          amountSent = amountSent + 1;\n+          signatures.push(signature);\n+          return { status: \"fulfilled\", value: signature };\n+        })\n+        .catch((error) => {\n+          console.error(`Transaction ${index + 1} failed:`, error);\n+          return { status: \"rejected\", reason: error };\n+        });\n+    });\n+\n+    await Promise.allSettled(sendPromises);\n+\n+    if (!(await sendPromises[0]).status === true) {\n+      // throw error that no tx was created\n+      throw new Error(\"no tx was created\");\n+    }\n+    updateLoadingText(\n+      `finalizing transaction(s)`,\n+      guardList,\n+      guardToUse.label,\n+      setGuardList\n+    );\n+\n+    createStandaloneToast().toast({\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\n+      status: \"success\",\n+      duration: 3000,\n+    });\n+    \n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\n+\n+    updateLoadingText(\n+      \"Fetching your NFT\",\n+      guardList,\n+      guardToUse.label,\n+      setGuardList\n+    );\n+\n+    // Filter out successful mints and map to fetch promises\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\n+      fetchNft(umi, mintResult).then((nftData) => ({\n+        mint: mintResult,\n+        nftData,\n+      }))\n+    );\n+\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\n+\n+    // Prepare data for setting mintsCreated\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\n+      [];\n+    fetchedNftsResults.map((acc) => {\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\n+        newMintsCreated.push({\n+          mint: acc.mint,\n+          offChainMetadata: acc.nftData.jsonMetadata,\n+        });\n+      }\n+      return acc;\n+    }, []);\n+\n+    // Update mintsCreated only if there are new mints\n+    if (newMintsCreated.length > 0) {\n+        setMintsCreated(newMintsCreated);\n+        onOpen();\n+    }\n+  } catch (e) {\n+    console.error(`minting failed because of ${e}`);\n+    createStandaloneToast().toast({\n+      title: \"Your mint failed!\",\n+      description: \"Please try again.\",\n+      status: \"error\",\n+      duration: 900,\n+      isClosable: true,\n+    });\n+  } finally {\n+    //find the guard by guardToUse.label and set minting to true\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n+    if (guardIndex === -1) {\n+      console.error(\"guard not found\");\n+      return;\n+    }\n+    const newGuardList = [...guardList];\n+    newGuardList[guardIndex].minting = false;\n+    setGuardList(newGuardList);\n+    setCheckEligibility(true);\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\n+  }\n+};\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\n+const Timer = ({\n+  solanaTime,\n+  toTime,\n+  setCheckEligibility,\n+}: {\n+  solanaTime: bigint;\n+  toTime: bigint;\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\n+}) => {\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\n+    toTime - solanaTime\n+  );\n+  useEffect(() => {\n+    const interval = setInterval(() => {\n+      setRemainingTime((prev) => {\n+        return prev - BigInt(1);\n+      });\n+    }, 1000);\n+    return () => clearInterval(interval);\n+  }, []);\n+\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\n+  const days = remainingTime / BigInt(86400);\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\n+  const seconds = remainingTime % BigInt(60);\n+  if (days > BigInt(0)) {\n+    return (\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\n+        {days.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        d{\" \"}\n+        {hours.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        h{\" \"}\n+        {minutes.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        m{\" \"}\n+        {seconds.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        s\n+      </Text>\n+    );\n+  }\n+  if (hours > BigInt(0)) {\n+    return (\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\n+        {hours.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        h{\" \"}\n+        {minutes.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        m{\" \"}\n+        {seconds.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        s\n+      </Text>\n+    );\n+  }\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\n+    return (\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\n+        {minutes.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        m{\" \"}\n+        {seconds.toLocaleString(\"en-US\", {\n+          minimumIntegerDigits: 2,\n+          useGrouping: false,\n+        })}\n+        s\n+      </Text>\n+    );\n+  }\n+  if (remainingTime === BigInt(0)) {\n+    setCheckEligibility(true);\n+  }\n+  return <Text></Text>;\n+};\n+\n+type Props = {\n+  umi: Umi;\n+  guardList: GuardReturn[];\n+  candyMachine: CandyMachine | undefined;\n+  candyGuard: CandyGuard | undefined;\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\n+  mintsCreated:\n+    | {\n+        mint: PublicKey;\n+        offChainMetadata: JsonMetadata | undefined;\n+      }[]\n+    | undefined;\n+  setMintsCreated: Dispatch<\n+    SetStateAction<\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\n+      | undefined\n+    >\n+  >;\n+  onOpen: () => void;\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\n+};\n+\n+export function ButtonList({\n+  umi,\n+  guardList,\n+  candyMachine,\n+  candyGuard,\n+  ownedTokens = [], // provide default empty array\n+  setGuardList,\n+  mintsCreated,\n+  setMintsCreated,\n+  onOpen,\n+  setCheckEligibility,\n+}: Props): JSX.Element {\n+  const solanaTime = useSolanaTime();\n+  const [numberInputValues, setNumberInputValues] = useState<{\n+    [label: string]: number;\n+  }>({});\n+  if (!candyMachine || !candyGuard) {\n+    return <></>;\n+  }\n+\n+  const handleNumberInputChange = (label: string, value: number) => {\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\n+  };\n+\n+  // remove duplicates from guardList\n+  //fucked up bugfix\n+  let filteredGuardlist = guardList.filter(\n+    (elem, index, self) =>\n+      index === self.findIndex((t) => t.label === elem.label)\n+  );\n+  if (filteredGuardlist.length === 0) {\n+    return <></>;\n+  }\n+  // Guard \"default\" can only be used to mint in case no other guard exists\n+  if (filteredGuardlist.length > 1) {\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\n+  }\n+  let buttonGuardList = [];\n+  for (const guard of filteredGuardlist) {\n+    const text = mintText.find((elem) => elem.label === guard.label);\n+    // find guard by label in candyGuard\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\n+    let startTime = createBigInt(0);\n+    let endTime = createBigInt(0);\n+    if (group) {\n+      if (group.guards.startDate.__option === \"Some\") {\n+        startTime = group.guards.startDate.value.date;\n+      }\n+      if (group.guards.endDate.__option === \"Some\") {\n+        endTime = group.guards.endDate.value.date;\n+      }\n+    }\n+\n+    let buttonElement: GuardButtonList = {\n+      label: guard ? guard.label : \"default\",\n+      allowed: guard.allowed,\n+      header: text ? text.header : \"header missing in settings.tsx\",\n+      mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\n+      buttonLabel: text\n+        ? text.buttonLabel\n+        : \"buttonLabel missing in settings.tsx\",\n+      startTime,\n+      endTime,\n+      tooltip: guard.reason,\n+      maxAmount: guard.maxAmount,\n+    };\n+    buttonGuardList.push(buttonElement);\n+  }\n+\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\n+    <Box key={index} marginTop={\"20px\"}>\n+      <Divider my=\"10px\" />\n+      <HStack>\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\n+          {buttonGuard.header}\n+        </Heading>\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\n+          {buttonGuard.endTime > createBigInt(0) &&\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\n+            (!buttonGuard.startTime ||\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\n+              <>\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\n+                  Ending in:{\" \"}\n+                </Text>\n+                <Timer\n+                  toTime={buttonGuard.endTime}\n+                  solanaTime={solanaTime}\n+                  setCheckEligibility={setCheckEligibility}\n+                />\n+              </>\n+            )}\n+          {buttonGuard.startTime > createBigInt(0) &&\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\n+            (!buttonGuard.endTime ||\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\n+              <>\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\n+                  Starting in:{\" \"}\n+                </Text>\n+                <Timer\n+                  toTime={buttonGuard.startTime}\n+                  solanaTime={solanaTime}\n+                  setCheckEligibility={setCheckEligibility}\n+                />\n+              </>\n+            )}\n+        </Flex>\n+      </HStack>\n+      <SimpleGrid columns={2} spacing={5}>\n+        <Text pt=\"2\" fontSize=\"sm\">\n+          {buttonGuard.mintText}\n+        </Text>\n+        <VStack>\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\n+            <NumberInput\n+              value={numberInputValues[buttonGuard.label] || 1}\n+              min={1}\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\n+              size=\"sm\"\n+              isDisabled={!buttonGuard.allowed}\n+              onChange={(valueAsString, valueAsNumber) =>\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\n+              }\n+            >\n+              <NumberInputField />\n+              <NumberInputStepper>\n+                <NumberIncrementStepper />\n+                <NumberDecrementStepper />\n+              </NumberInputStepper>\n+            </NumberInput>\n+          ) : null}\n+\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\n+            <Button\n+              onClick={() =>\n+                mintClick(\n+                  umi,\n+                  buttonGuard,\n+                  candyMachine,\n+                  candyGuard,\n+                  ownedTokens,\n+                  numberInputValues[buttonGuard.label] || 1,\n+                  mintsCreated,\n+                  setMintsCreated,\n+                  guardList,\n+                  setGuardList,\n+                  onOpen,\n+                  setCheckEligibility\n+                )\n+              }\n+              key={buttonGuard.label}\n+              size=\"sm\"\n+              backgroundColor=\"teal.100\"\n+              isDisabled={!buttonGuard.allowed}\n+              isLoading={\n+                guardList.find((elem) => elem.label === buttonGuard.label)\n+                  ?.minting\n+              }\n+              loadingText={\n+                guardList.find((elem) => elem.label === buttonGuard.label)\n+                  ?.loadingText\n+              }\n+            >\n+              {buttonGuard.buttonLabel}\n+            </Button>\n+          </Tooltip>\n+        </VStack>\n+      </SimpleGrid>\n+    </Box>\n+  ));\n+\n+  return <>{listItems}</>;\n+}\n"
                },
                {
                    "date": 1731243180446,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,642 +5,136 @@\n } from \"@metaplex-foundation/mpl-candy-machine\";\n import { GuardReturn } from \"../utils/checkerHelper\";\n import {\n   AddressLookupTableInput,\n-  KeypairSigner,\n   PublicKey,\n-  Transaction,\n   Umi,\n-  createBigInt,\n-  generateSigner,\n-  none,\n+  transactionBuilder,\n   publicKey,\n-  signAllTransactions,\n-  signTransaction,\n-  sol,\n   some,\n-  transactionBuilder,\n+  none,\n } from \"@metaplex-foundation/umi\";\n import {\n-  DigitalAsset,\n   DigitalAssetWithToken,\n-  JsonMetadata,\n-  fetchDigitalAsset,\n-  fetchJsonMetadata,\n } from \"@metaplex-foundation/mpl-token-metadata\";\n import { mintText } from \"../settings\";\n import {\n-  Box,\n   Button,\n-  Flex,\n-  HStack,\n-  Heading,\n-  SimpleGrid,\n-  Text,\n+  InputNumber,\n   Tooltip,\n-  NumberInput,\n-  NumberInputField,\n-  NumberInputStepper,\n-  NumberIncrementStepper,\n-  NumberDecrementStepper,\n-  VStack,\n+  Typography,\n   Divider,\n-  createStandaloneToast,\n-} from \"@chakra-ui/react\";\n+  Row,\n+  Col,\n+} from \"antd\"; // ä½¿ç”¨ Ant Design çš„ç»„ä»¶\n import {\n-  fetchAddressLookupTable, setComputeUnitPrice,\n+  fetchAddressLookupTable,\n+  setComputeUnitPrice,\n } from \"@metaplex-foundation/mpl-toolbox\";\n import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\n import {\n   chooseGuardToUse,\n   routeBuilder,\n   mintArgsBuilder,\n-  GuardButtonList,\n   buildTx,\n   getRequiredCU,\n } from \"../utils/mintHelper\";\n import { useSolanaTime } from \"@/utils/SolanaTimeContext\";\n import { verifyTx } from \"@/utils/verifyTx\";\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\n \n-const updateLoadingText = (\n-  loadingText: string | undefined,\n-  guardList: GuardReturn[],\n-  label: string,\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\n-) => {\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\n-  if (guardIndex === -1) {\n-    console.error(\"guard not found\");\n-    return;\n-  }\n-  const newGuardList = [...guardList];\n-  newGuardList[guardIndex].loadingText = loadingText;\n-  setGuardList(newGuardList);\n-};\n-\n-const fetchNft = async (\n-  umi: Umi,\n-  nftAdress: PublicKey,\n-) => {\n-  let digitalAsset: DigitalAsset | undefined;\n-  let jsonMetadata: JsonMetadata | undefined;\n-  try {\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\n-  } catch (e) {\n-    console.error(e);\n-    createStandaloneToast().toast({\n-      title: \"Nft could not be fetched!\",\n-      description: \"Please check your Wallet instead.\",\n-      status: \"info\",\n-      duration: 900,\n-      isClosable: true,\n-    });\n-  }\n-\n-  return { digitalAsset, jsonMetadata };\n-};\n-\n-const mintClick = async (\n-  umi: Umi,\n-  guard: GuardReturn,\n-  candyMachine: CandyMachine,\n-  candyGuard: CandyGuard,\n-  ownedTokens: DigitalAssetWithToken[],\n-  mintAmount: number,\n-  mintsCreated:\n-    | {\n-        mint: PublicKey;\n-        offChainMetadata: JsonMetadata | undefined;\n-      }[]\n-    | undefined,\n-  setMintsCreated: Dispatch<\n-    SetStateAction<\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\n-      | undefined\n-    >\n-  >,\n-  guardList: GuardReturn[],\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\n-  onOpen: () => void,\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\n-) => {\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\n-  if (!guardToUse.guards) {\n-    console.error(\"no guard defined!\");\n-    return;\n-  }\n-\n-  let buyBeer = true;\n-  console.log(\"buyBeer\",process.env.NEXT_PUBLIC_BUYMARKBEER )\n-\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER  === \"false\") {\n-    buyBeer = false;\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer ðŸ˜’\");\n-  }\n-\n-  try {\n-    //find the guard by guardToUse.label and set minting to true\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n-    if (guardIndex === -1) {\n-      console.error(\"guard not found\");\n-      return;\n-    }\n-    const newGuardList = [...guardList];\n-    newGuardList[guardIndex].minting = true;\n-    setGuardList(newGuardList);\n-\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\n-    if (routeBuild && routeBuild.items.length > 0) {\n-      createStandaloneToast().toast({\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\n-        status: \"info\",\n-        duration: 900,\n-        isClosable: true,\n-      });\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({commitment: \"finalized\"});\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\n-      const builtTx = await routeBuild.buildAndSign(umi);\n-      const sig = await umi.rpc\n-        .sendTransaction(builtTx, { skipPreflight:true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n-        .then((signature) => {\n-          return { status: \"fulfilled\", value: signature };\n-        })\n-        .catch((error) => {\n-          createStandaloneToast().toast({\n-            title: \"Allow List TX failed!\",\n-            status: \"error\",\n-            duration: 900,\n-            isClosable: true,\n-          });\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\n-\n-        });\n-        if (sig.status === \"fulfilled\")\n-          await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\n-\n-    }\n-\n-    // fetch LUT\n-    let tables: AddressLookupTableInput[] = [];\n-    const lut = process.env.NEXT_PUBLIC_LUT;\n-    if (lut) {\n-      const lutPubKey = publicKey(lut);\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\n-      tables = [fetchedLut];\n-    } else {\n-      createStandaloneToast().toast({\n-        title: \"The developer should really set a lookup table!\",\n-        status: \"warning\",\n-        duration: 900,\n-        isClosable: true,\n-      });\n-    }\n-\n-    const mintTxs: Transaction[] = [];\n-    let nftsigners = [] as KeypairSigner[];\n-\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({commitment: \"finalized\"}));\n-    \n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\n-    const nftMint = generateSigner(umi);\n-    const txForSimulation = buildTx(\n-      umi,\n-      candyMachine,\n-      candyGuard,\n-      nftMint,\n-      guardToUse,\n-      mintArgs,\n-      tables,\n-      latestBlockhash,\n-      1_400_000,\n-      buyBeer\n-    );\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\n-\n-    for (let i = 0; i < mintAmount; i++) {\n-      const nftMint = generateSigner(umi);\n-      nftsigners.push(nftMint);\n-      const transaction = buildTx(\n-        umi,\n-        candyMachine,\n-        candyGuard,\n-        nftMint,\n-        guardToUse,\n-        mintArgs,\n-        tables,\n-        latestBlockhash,\n-        requiredCu,\n-        buyBeer\n-      );\n-      console.log(transaction)\n-      mintTxs.push(transaction);\n-    }\n-    if (!mintTxs.length) {\n-      console.error(\"no mint tx built!\");\n-      return;\n-    }\n-\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\n-    const signedTransactions = await signAllTransactions(\n-      mintTxs.map((transaction, index) => ({\n-        transaction,\n-        signers: [umi.payer, nftsigners[index]],\n-      }))\n-    );\n-\n-    let signatures: Uint8Array[] = [];\n-    let amountSent = 0;\n-    \n-    const sendPromises = signedTransactions.map((tx, index) => {\n-      return umi.rpc\n-        .sendTransaction(tx, { skipPreflight:true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n-        .then((signature) => {\n-          console.log(\n-            `Transaction ${index + 1} resolved with signature: ${\n-              base58.deserialize(signature)[0]\n-            }`\n-          );\n-          amountSent = amountSent + 1;\n-          signatures.push(signature);\n-          return { status: \"fulfilled\", value: signature };\n-        })\n-        .catch((error) => {\n-          console.error(`Transaction ${index + 1} failed:`, error);\n-          return { status: \"rejected\", reason: error };\n-        });\n-    });\n-\n-    await Promise.allSettled(sendPromises);\n-\n-    if (!(await sendPromises[0]).status === true) {\n-      // throw error that no tx was created\n-      throw new Error(\"no tx was created\");\n-    }\n-    updateLoadingText(\n-      `finalizing transaction(s)`,\n-      guardList,\n-      guardToUse.label,\n-      setGuardList\n-    );\n-\n-    createStandaloneToast().toast({\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\n-      status: \"success\",\n-      duration: 3000,\n-    });\n-    \n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\n-\n-    updateLoadingText(\n-      \"Fetching your NFT\",\n-      guardList,\n-      guardToUse.label,\n-      setGuardList\n-    );\n-\n-    // Filter out successful mints and map to fetch promises\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\n-      fetchNft(umi, mintResult).then((nftData) => ({\n-        mint: mintResult,\n-        nftData,\n-      }))\n-    );\n-\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\n-\n-    // Prepare data for setting mintsCreated\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\n-      [];\n-    fetchedNftsResults.map((acc) => {\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\n-        newMintsCreated.push({\n-          mint: acc.mint,\n-          offChainMetadata: acc.nftData.jsonMetadata,\n-        });\n-      }\n-      return acc;\n-    }, []);\n-\n-    // Update mintsCreated only if there are new mints\n-    if (newMintsCreated.length > 0) {\n-        setMintsCreated(newMintsCreated);\n-        onOpen();\n-    }\n-  } catch (e) {\n-    console.error(`minting failed because of ${e}`);\n-    createStandaloneToast().toast({\n-      title: \"Your mint failed!\",\n-      description: \"Please try again.\",\n-      status: \"error\",\n-      duration: 900,\n-      isClosable: true,\n-    });\n-  } finally {\n-    //find the guard by guardToUse.label and set minting to true\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n-    if (guardIndex === -1) {\n-      console.error(\"guard not found\");\n-      return;\n-    }\n-    const newGuardList = [...guardList];\n-    newGuardList[guardIndex].minting = false;\n-    setGuardList(newGuardList);\n-    setCheckEligibility(true);\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\n-  }\n-};\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\n-const Timer = ({\n-  solanaTime,\n-  toTime,\n-  setCheckEligibility,\n-}: {\n-  solanaTime: bigint;\n-  toTime: bigint;\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\n-}) => {\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\n-    toTime - solanaTime\n-  );\n-  useEffect(() => {\n-    const interval = setInterval(() => {\n-      setRemainingTime((prev) => {\n-        return prev - BigInt(1);\n-      });\n-    }, 1000);\n-    return () => clearInterval(interval);\n-  }, []);\n-\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\n-  const days = remainingTime / BigInt(86400);\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\n-  const seconds = remainingTime % BigInt(60);\n-  if (days > BigInt(0)) {\n-    return (\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\n-        {days.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        d{\" \"}\n-        {hours.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        h{\" \"}\n-        {minutes.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        m{\" \"}\n-        {seconds.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        s\n-      </Text>\n-    );\n-  }\n-  if (hours > BigInt(0)) {\n-    return (\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\n-        {hours.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        h{\" \"}\n-        {minutes.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        m{\" \"}\n-        {seconds.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        s\n-      </Text>\n-    );\n-  }\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\n-    return (\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\n-        {minutes.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        m{\" \"}\n-        {seconds.toLocaleString(\"en-US\", {\n-          minimumIntegerDigits: 2,\n-          useGrouping: false,\n-        })}\n-        s\n-      </Text>\n-    );\n-  }\n-  if (remainingTime === BigInt(0)) {\n-    setCheckEligibility(true);\n-  }\n-  return <Text></Text>;\n-};\n-\n-type Props = {\n-  umi: Umi;\n-  guardList: GuardReturn[];\n-  candyMachine: CandyMachine | undefined;\n-  candyGuard: CandyGuard | undefined;\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\n-  mintsCreated:\n-    | {\n-        mint: PublicKey;\n-        offChainMetadata: JsonMetadata | undefined;\n-      }[]\n-    | undefined;\n-  setMintsCreated: Dispatch<\n-    SetStateAction<\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\n-      | undefined\n-    >\n-  >;\n-  onOpen: () => void;\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\n-};\n-\n-export function ButtonList({\n+const MintButton = ({\n   umi,\n   guardList,\n   candyMachine,\n   candyGuard,\n-  ownedTokens = [], // provide default empty array\n+  ownedTokens = [],\n   setGuardList,\n   mintsCreated,\n   setMintsCreated,\n   onOpen,\n   setCheckEligibility,\n-}: Props): JSX.Element {\n+}) => {\n   const solanaTime = useSolanaTime();\n-  const [numberInputValues, setNumberInputValues] = useState<{\n-    [label: string]: number;\n-  }>({});\n-  if (!candyMachine || !candyGuard) {\n-    return <></>;\n-  }\n+  const [numberInputValues, setNumberInputValues] = useState({});\n \n-  const handleNumberInputChange = (label: string, value: number) => {\n+  const handleNumberInputChange = (label, value) => {\n     setNumberInputValues((prev) => ({ ...prev, [label]: value }));\n   };\n \n-  // remove duplicates from guardList\n-  //fucked up bugfix\n-  let filteredGuardlist = guardList.filter(\n-    (elem, index, self) =>\n-      index === self.findIndex((t) => t.label === elem.label)\n-  );\n-  if (filteredGuardlist.length === 0) {\n-    return <></>;\n-  }\n-  // Guard \"default\" can only be used to mint in case no other guard exists\n-  if (filteredGuardlist.length > 1) {\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\n-  }\n-  let buttonGuardList = [];\n-  for (const guard of filteredGuardlist) {\n-    const text = mintText.find((elem) => elem.label === guard.label);\n-    // find guard by label in candyGuard\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\n-    let startTime = createBigInt(0);\n-    let endTime = createBigInt(0);\n-    if (group) {\n-      if (group.guards.startDate.__option === \"Some\") {\n-        startTime = group.guards.startDate.value.date;\n-      }\n-      if (group.guards.endDate.__option === \"Some\") {\n-        endTime = group.guards.endDate.value.date;\n-      }\n+  const mintClick = async (guard) => {\n+    const guardToUse = chooseGuardToUse(guard, candyGuard);\n+    if (!guardToUse.guards) {\n+      console.error(\"no guard defined!\");\n+      return;\n     }\n \n-    let buttonElement: GuardButtonList = {\n-      label: guard ? guard.label : \"default\",\n-      allowed: guard.allowed,\n-      header: text ? text.header : \"header missing in settings.tsx\",\n-      mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\n-      buttonLabel: text\n-        ? text.buttonLabel\n-        : \"buttonLabel missing in settings.tsx\",\n-      startTime,\n-      endTime,\n-      tooltip: guard.reason,\n-      maxAmount: guard.maxAmount,\n-    };\n-    buttonGuardList.push(buttonElement);\n-  }\n+    try {\n+      const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\n+      const tx = buildTx(\n+        umi,\n+        candyMachine,\n+        candyGuard,\n+        publicKey(umi.identity.publicKey),\n+        guardToUse,\n+        mintArgs,\n+        [],\n+        (await umi.rpc.getLatestBlockhash()).blockhash,\n+        1_400_000,\n+        true\n+      );\n \n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\n-    <Box key={index} marginTop={\"20px\"}>\n-      <Divider my=\"10px\" />\n-      <HStack>\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\n-          {buttonGuard.header}\n-        </Heading>\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\n-          {buttonGuard.endTime > createBigInt(0) &&\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\n-            (!buttonGuard.startTime ||\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\n-              <>\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\n-                  Ending in:{\" \"}\n-                </Text>\n-                <Timer\n-                  toTime={buttonGuard.endTime}\n-                  solanaTime={solanaTime}\n-                  setCheckEligibility={setCheckEligibility}\n-                />\n-              </>\n-            )}\n-          {buttonGuard.startTime > createBigInt(0) &&\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\n-            (!buttonGuard.endTime ||\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\n-              <>\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\n-                  Starting in:{\" \"}\n-                </Text>\n-                <Timer\n-                  toTime={buttonGuard.startTime}\n-                  solanaTime={solanaTime}\n-                  setCheckEligibility={setCheckEligibility}\n-                />\n-              </>\n-            )}\n-        </Flex>\n-      </HStack>\n-      <SimpleGrid columns={2} spacing={5}>\n-        <Text pt=\"2\" fontSize=\"sm\">\n-          {buttonGuard.mintText}\n-        </Text>\n-        <VStack>\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\n-            <NumberInput\n-              value={numberInputValues[buttonGuard.label] || 1}\n-              min={1}\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\n-              size=\"sm\"\n-              isDisabled={!buttonGuard.allowed}\n-              onChange={(valueAsString, valueAsNumber) =>\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\n-              }\n-            >\n-              <NumberInputField />\n-              <NumberInputStepper>\n-                <NumberIncrementStepper />\n-                <NumberDecrementStepper />\n-              </NumberInputStepper>\n-            </NumberInput>\n-          ) : null}\n+      const requiredCu = await getRequiredCU(umi, tx);\n+      const signatures = await verifyTx(umi, [tx], (await umi.rpc.getLatestBlockhash()).blockhash, \"finalized\");\n \n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\n-            <Button\n-              onClick={() =>\n-                mintClick(\n-                  umi,\n-                  buttonGuard,\n-                  candyMachine,\n-                  candyGuard,\n-                  ownedTokens,\n-                  numberInputValues[buttonGuard.label] || 1,\n-                  mintsCreated,\n-                  setMintsCreated,\n-                  guardList,\n-                  setGuardList,\n-                  onOpen,\n-                  setCheckEligibility\n-                )\n-              }\n-              key={buttonGuard.label}\n-              size=\"sm\"\n-              backgroundColor=\"teal.100\"\n-              isDisabled={!buttonGuard.allowed}\n-              isLoading={\n-                guardList.find((elem) => elem.label === buttonGuard.label)\n-                  ?.minting\n-              }\n-              loadingText={\n-                guardList.find((elem) => elem.label === buttonGuard.label)\n-                  ?.loadingText\n-              }\n-            >\n-              {buttonGuard.buttonLabel}\n-            </Button>\n-          </Tooltip>\n-        </VStack>\n-      </SimpleGrid>\n-    </Box>\n-  ));\n+      notification.success({\n+        message: `${signatures.length} Transaction(s) sent!`,\n+        duration: 3,\n+      });\n+    } catch (e) {\n+      console.error(`minting failed because of ${e}`);\n+      notification.error({\n+        message: \"Your mint failed!\",\n+        description: \"Please try again.\",\n+        duration: 3,\n+      });\n+    }\n+  };\n \n-  return <>{listItems}</>;\n-}\n+  return (\n+    <div>\n+      {guardList.map((guard, index) => (\n+        <div key={index} style={{ marginTop: \"20px\" }}>\n+          <Divider />\n+          <Row>\n+            <Col span={12}>\n+              <Typography.Text strong>{guard.label}</Typography.Text>\n+            </Col>\n+            <Col span={12} style={{ textAlign: \"right\" }}>\n+              <Tooltip title={guard.reason}>\n+                <Button\n+                  onClick={() => mintClick(guard)}\n+                  type=\"primary\"\n+                  disabled={!guard.allowed}\n+                >\n+                  {guard.label}\n+                </Button>\n+              </Tooltip>\n+            </Col>\n+          </Row>\n+          <Row>\n+            <Col span={24}>\n+              <InputNumber\n+                min={1}\n+                max={guard.maxAmount < 1 ? 1 : guard.maxAmount}\n+                defaultValue={numberInputValues[guard.label] || 1}\n+                onChange={(value) => handleNumberInputChange(guard.label, value)}\n+              />\n+            </Col>\n+          </Row>\n+        </div>\n+      ))}\n+    </div>\n+  );\n+};\n+\n+export default MintButton;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731243199441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,10 +37,10 @@\n   mintArgsBuilder,\n   buildTx,\n   getRequiredCU,\n } from \"../utils/mintHelper\";\n-import { useSolanaTime } from \"@/utils/SolanaTimeContext\";\n-import { verifyTx } from \"@/utils/verifyTx\";\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\n+import { verifyTx } from \".././utils/verifyTx\";\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\n \n const MintButton = ({\n   umi,\n"
                },
                {
                    "date": 1731243240003,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -85,19 +85,19 @@\n \n       const requiredCu = await getRequiredCU(umi, tx);\n       const signatures = await verifyTx(umi, [tx], (await umi.rpc.getLatestBlockhash()).blockhash, \"finalized\");\n \n-      notification.success({\n-        message: `${signatures.length} Transaction(s) sent!`,\n-        duration: 3,\n-      });\n+      // notification.success({\n+      //   message: `${signatures.length} Transaction(s) sent!`,\n+      //   duration: 3,\n+      // });\n     } catch (e) {\n       console.error(`minting failed because of ${e}`);\n-      notification.error({\n-        message: \"Your mint failed!\",\n-        description: \"Please try again.\",\n-        duration: 3,\n-      });\n+      // notification.error({\n+      //   message: \"Your mint failed!\",\n+      //   description: \"Please try again.\",\n+      //   duration: 3,\n+      // });\n     }\n   };\n \n   return (\n@@ -136,516 +136,5 @@\n     </div>\n   );\n };\n \n-export default MintButton;\n-import {\n-  CandyGuard,\n-  CandyMachine,\n-  mintV2,\n-} from \"@metaplex-foundation/mpl-candy-machine\";\n-import { GuardReturn } from \"../utils/checkerHelper\";\n-import {\n-  AddressLookupTableInput,\n-  PublicKey,\n-  Umi,\n-  transactionBuilder,\n-  publicKey,\n-  some,\n-  none,\n-} from \"@metaplex-foundation/umi\";\n-import {\n-  DigitalAssetWithToken,\n-} from \"@metaplex-foundation/mpl-token-metadata\";\n-import { mintText } from \".././settings\";\n-import {\n-  Button,\n-  Divider,\n-  InputNumber,\n-  notification,\n-  Row,\n-  Col,\n-  Tooltip,\n-} from \"antd\"; // ä½¿ç”¨ Ant Design çš„ç»„ä»¶\n-import {\n-  fetchAddressLookupTable,\n-  setComputeUnitPrice,\n-} from \"@metaplex-foundation/mpl-toolbox\";\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\n-import {\n-  chooseGuardToUse,\n-  routeBuilder,\n-  mintArgsBuilder,\n-  buildTx,\n-  getRequiredCU,\n-} from \"../utils/mintHelper\";\n-import { useSolanaTime } from \"../utils/SolanaTimeContext\";\n-import { verifyTx } from \"../utils/verifyTx\";\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\n-import {\n-  DigitalAsset,\n-  JsonMetadata,\n-  fetchDigitalAsset,\n-  fetchJsonMetadata,\n-} from \"@metaplex-foundation/mpl-token-metadata\";\n-\n-const updateLoadingText = (\n-  loadingText,\n-  guardList,\n-  label,\n-  setGuardList\n-) => {\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\n-  if (guardIndex === -1) {\n-    console.error(\"guard not found\");\n-    return;\n-  }\n-  const newGuardList = [...guardList];\n-  newGuardList[guardIndex].loadingText = loadingText;\n-  setGuardList(newGuardList);\n-};\n-\n-const fetchNft = async (\n-  umi,\n-  nftAddress\n-) => {\n-  let digitalAsset;\n-  let jsonMetadata;\n-  try {\n-    digitalAsset = await fetchDigitalAsset(umi, nftAddress);\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\n-  } catch (e) {\n-    console.error(e);\n-    notification.info({\n-      message: \"NFT could not be fetched!\",\n-      description: \"Please check your Wallet instead.\",\n-      duration: 9,\n-    });\n-  }\n-\n-  return { digitalAsset, jsonMetadata };\n-};\n-\n-const mintClick = async (\n-  umi,\n-  guard,\n-  candyMachine,\n-  candyGuard,\n-  ownedTokens,\n-  mintAmount,\n-  mintsCreated,\n-  setMintsCreated,\n-  guardList,\n-  setGuardList,\n-  onOpen,\n-  setCheckEligibility\n-) => {\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\n-  if (!guardToUse.guards) {\n-    console.error(\"no guard defined!\");\n-    return;\n-  }\n-\n-  let buyBeer = true;\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER);\n-\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\n-    buyBeer = false;\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer ðŸ˜’\");\n-  }\n-\n-  try {\n-    // Find the guard by guardToUse.label and set minting to true\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n-    if (guardIndex === -1) {\n-      console.error(\"guard not found\");\n-      return;\n-    }\n-    const newGuardList = [...guardList];\n-    newGuardList[guardIndex].minting = true;\n-    setGuardList(newGuardList);\n-\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\n-    if (routeBuild && routeBuild.items.length > 0) {\n-      notification.info({\n-        message: \"Allowlist detected. Please sign to be approved to mint.\",\n-        duration: 9,\n-      });\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash);\n-      const builtTx = await routeBuild.buildAndSign(umi);\n-      const sig = await umi.rpc\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n-        .then((signature) => {\n-          return { status: \"fulfilled\", value: signature };\n-        })\n-        .catch((error) => {\n-          notification.error({\n-            message: \"Allow List TX failed!\",\n-            duration: 9,\n-          });\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\n-        });\n-\n-      if (sig.status === \"fulfilled\")\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\n-    }\n-\n-    // Fetch LUT\n-    let tables = [];\n-    const lut = process.env.NEXT_PUBLIC_LUT;\n-    if (lut) {\n-      const lutPubKey = publicKey(lut);\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\n-      tables = [fetchedLut];\n-    } else {\n-      notification.warning({\n-        message: \"The developer should really set a lookup table!\",\n-        duration: 9,\n-      });\n-    }\n-\n-    const mintTxs = [];\n-    let nftSigners = [];\n-\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\n-\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\n-    const nftMint = generateSigner(umi);\n-    const txForSimulation = buildTx(\n-      umi,\n-      candyMachine,\n-      candyGuard,\n-      nftMint,\n-      guardToUse,\n-      mintArgs,\n-      tables,\n-      latestBlockhash,\n-      1_400_000,\n-      buyBeer\n-    );\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\n-\n-    for (let i = 0; i < mintAmount; i++) {\n-      const nftMint = generateSigner(umi);\n-      nftSigners.push(nftMint);\n-      const transaction = buildTx(\n-        umi,\n-        candyMachine,\n-        candyGuard,\n-        nftMint,\n-        guardToUse,\n-        mintArgs,\n-        tables,\n-        latestBlockhash,\n-        requiredCu,\n-        buyBeer\n-      );\n-      mintTxs.push(transaction);\n-    }\n-    if (!mintTxs.length) {\n-      console.error(\"no mint tx built!\");\n-      return;\n-    }\n-\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\n-    const signedTransactions = await signAllTransactions(\n-      mintTxs.map((transaction, index) => ({\n-        transaction,\n-        signers: [umi.payer, nftSigners[index]],\n-      }))\n-    );\n-\n-    let signatures = [];\n-    let amountSent = 0;\n-\n-    const sendPromises = signedTransactions.map((tx, index) => {\n-      return umi.rpc\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n-        .then((signature) => {\n-          console.log(\n-            `Transaction ${index + 1} resolved with signature: ${\n-              base58.deserialize(signature)[0]\n-            }`\n-          );\n-          amountSent += 1;\n-          signatures.push(signature);\n-          return { status: \"fulfilled\", value: signature };\n-        })\n-        .catch((error) => {\n-          console.error(`Transaction ${index + 1} failed:`, error);\n-          return { status: \"rejected\", reason: error };\n-        });\n-    });\n-\n-    await Promise.allSettled(sendPromises);\n-\n-    if (!(await sendPromises[0]).status === true) {\n-      // throw error that no tx was created\n-      throw new Error(\"no tx was created\");\n-    }\n-    updateLoadingText(\n-      `finalizing transaction(s)`,\n-      guardList,\n-      guardToUse.label,\n-      setGuardList\n-    );\n-\n-    notification.success({\n-      message: `${signedTransactions.length} Transaction(s) sent!`,\n-      duration: 3,\n-    });\n-\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\n-\n-    updateLoadingText(\n-      \"Fetching your NFT\",\n-      guardList,\n-      guardToUse.label,\n-      setGuardList\n-    );\n-\n-    // Filter out successful mints and map to fetch promises\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\n-      fetchNft(umi, mintResult).then((nftData) => ({\n-        mint: mintResult,\n-        nftData,\n-      }))\n-    );\n-\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\n-\n-    // Prepare data for setting mintsCreated\n-    let newMintsCreated = [];\n-    fetchedNftsResults.map((acc) => {\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\n-        newMintsCreated.push({\n-          mint: acc.mint,\n-          offChainMetadata: acc.nftData.jsonMetadata,\n-        });\n-      }\n-      return acc;\n-    });\n-\n-    // Update mintsCreated only if there are new mints\n-    if (newMintsCreated.length > 0) {\n-      setMintsCreated(newMintsCreated);\n-      onOpen();\n-    }\n-  } catch (e) {\n-    console.error(`minting failed because of ${e}`);\n-    notification.error({\n-      message: \"Your mint failed!\",\n-      description: \"Please try again.\",\n-      duration: 9,\n-    });\n-  } finally {\n-    // Find the guard by guardToUse.label and set minting to false\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n-    if (guardIndex === -1) {\n-      console.error(\"guard not found\");\n-      return;\n-    }\n-    const newGuardList = [...guardList];\n-    newGuardList[guardIndex].minting = false;\n-    setGuardList(newGuardList);\n-    setCheckEligibility(true);\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\n-  }\n-};\n-\n-// Timer component\n-const Timer = ({\n-  solanaTime,\n-  toTime,\n-  setCheckEligibility,\n-}) => {\n-  const [remainingTime, setRemainingTime] = useState(toTime - solanaTime);\n-  useEffect(() => {\n-    const interval = setInterval(() => {\n-      setRemainingTime((prev) => prev - BigInt(1));\n-    }, 1000);\n-    return () => clearInterval(interval);\n-  }, []);\n-\n-  const days = remainingTime / BigInt(86400);\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\n-  const seconds = remainingTime % BigInt(60);\n-  \n-  if (days > BigInt(0)) {\n-    return (\n-      <Text>\n-        {days.toString()} d {hours.toString()} h {minutes.toString()} m {seconds.toString()} s\n-      </Text>\n-    );\n-  }\n-  if (hours > BigInt(0)) {\n-    return (\n-      <Text>\n-        {hours.toString()} h {minutes.toString()} m {seconds.toString()} s\n-      </Text>\n-    );\n-  }\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\n-    return (\n-      <Text>\n-        {minutes.toString()} m {seconds.toString()} s\n-      </Text>\n-    );\n-  }\n-  if (remainingTime === BigInt(0)) {\n-    setCheckEligibility(true);\n-  }\n-  return <Text></Text>;\n-};\n-\n-export function ButtonList({\n-  umi,\n-  guardList,\n-  candyMachine,\n-  candyGuard,\n-  ownedTokens = [],\n-  setGuardList,\n-  mintsCreated,\n-  setMintsCreated,\n-  onOpen,\n-  setCheckEligibility,\n-}) {\n-  const solanaTime = useSolanaTime();\n-  const [numberInputValues, setNumberInputValues] = useState({});\n-\n-  if (!candyMachine || !candyGuard) {\n-    return <></>;\n-  }\n-\n-  const handleNumberInputChange = (label, value) => {\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\n-  };\n-\n-  let filteredGuardlist = guardList.filter(\n-    (elem, index, self) =>\n-      index === self.findIndex((t) => t.label === elem.label)\n-  );\n-\n-  if (filteredGuardlist.length === 0) {\n-    return <></>;\n-  }\n-\n-  if (filteredGuardlist.length > 1) {\n-    filteredGuardlist = guardList.filter((elem) => elem.label !== \"default\");\n-  }\n-\n-  let buttonGuardList = [];\n-  for (const guard of filteredGuardlist) {\n-    const text = mintText.find((elem) => elem.label === guard.label);\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\n-    let startTime = BigInt(0);\n-    let endTime = BigInt(0);\n-    if (group) {\n-      if (group.guards.startDate.__option === \"Some\") {\n-        startTime = group.guards.startDate.value.date;\n-      }\n-      if (group.guards.endDate.__option === \"Some\") {\n-        endTime = group.guards.endDate.value.date;\n-      }\n-    }\n-\n-    let buttonElement = {\n-      label: guard ? guard.label : \"default\",\n-      allowed: guard.allowed,\n-      header: text ? text.header : \"header missing in settings.tsx\",\n-      mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\n-      buttonLabel: text ? text.buttonLabel : \"buttonLabel missing in settings.tsx\",\n-      startTime,\n-      endTime,\n-      tooltip: guard.reason,\n-      maxAmount: guard.maxAmount,\n-    };\n-    buttonGuardList.push(buttonElement);\n-  }\n-\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\n-    <div key={index} style={{ marginTop: \"20px\" }}>\n-      <Divider />\n-      <Row>\n-        <Col>\n-          <Text strong>{buttonGuard.header}</Text>\n-        </Col>\n-        <Col style={{ textAlign: \"right\" }}>\n-          {buttonGuard.endTime > BigInt(0) &&\n-            buttonGuard.endTime - solanaTime > BigInt(0) &&\n-            (!buttonGuard.startTime ||\n-              buttonGuard.startTime - solanaTime <= BigInt(0)) && (\n-              <>\n-                <Text>Ending in: </Text>\n-                <Timer\n-                  toTime={buttonGuard.endTime}\n-                  solanaTime={solanaTime}\n-                  setCheckEligibility={setCheckEligibility}\n-                />\n-              </>\n-            )}\n-          {buttonGuard.startTime > BigInt(0) &&\n-            buttonGuard.startTime - solanaTime > BigInt(0) &&\n-            (!buttonGuard.endTime ||\n-              solanaTime - buttonGuard.endTime <= BigInt(0)) && (\n-              <>\n-                <Text>Starting in: </Text>\n-                <Timer\n-                  toTime={buttonGuard.startTime}\n-                  solanaTime={solanaTime}\n-                  setCheckEligibility={setCheckEligibility}\n-                />\n-              </>\n-            )}\n-        </Col>\n-      </Row>\n-      <Row>\n-        <Text>{buttonGuard.mintText}</Text>\n-        <Col>\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\n-            <InputNumber\n-              value={numberInputValues[buttonGuard.label] || 1}\n-              min={1}\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\n-              onChange={(value) => handleNumberInputChange(buttonGuard.label, value)}\n-            />\n-          ) : null}\n-\n-          <Tooltip title={buttonGuard.tooltip}>\n-            <Button\n-              onClick={() =>\n-                mintClick(\n-                  umi,\n-                  buttonGuard,\n-                  candyMachine,\n-                  candyGuard,\n-                  ownedTokens,\n-                  numberInputValues[buttonGuard.label] || 1,\n-                  mintsCreated,\n-                  setMintsCreated,\n-                  guardList,\n-                  setGuardList,\n-                  onOpen,\n-                  setCheckEligibility\n-                )\n-              }\n-              key={buttonGuard.label}\n-              type=\"primary\"\n-              disabled={!buttonGuard.allowed}\n-              loading={\n-                guardList.find((elem) => elem.label === buttonGuard.label)\n-                  ?.minting\n-              }\n-            >\n-              {buttonGuard.buttonLabel}\n-            </Button>\n-          </Tooltip>\n-        </Col>\n-      </Row>\n-    </div>\n-  ));\n-\n-  return <>{listItems}</>;\n-}\n\\ No newline at end of file\n+export default MintButton;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731241792388,
            "name": "Commit-0",
            "content": "import {\n  CandyGuard,\n  CandyMachine,\n  mintV2,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport { GuardReturn } from \"../utils/checkerHelper\";\nimport {\n  AddressLookupTableInput,\n  PublicKey,\n  Umi,\n  transactionBuilder,\n  publicKey,\n  some,\n  none,\n} from \"@metaplex-foundation/umi\";\nimport {\n  DigitalAssetWithToken,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { mintText } from \".././settings\";\nimport {\n  Button,\n  Divider,\n  InputNumber,\n  notification,\n  Row,\n  Col,\n  Tooltip,\n} from \"antd\"; // ä½¿ç”¨ Ant Design çš„ç»„ä»¶\nimport {\n  fetchAddressLookupTable,\n  setComputeUnitPrice,\n} from \"@metaplex-foundation/mpl-toolbox\";\nimport { Dispatch, SetStateAction, useEffect, useState } from \"react\";\nimport {\n  chooseGuardToUse,\n  routeBuilder,\n  mintArgsBuilder,\n  buildTx,\n  getRequiredCU,\n} from \"../utils/mintHelper\";\nimport { useSolanaTime } from \"../utils/SolanaTimeContext\";\nimport { verifyTx } from \"../utils/verifyTx\";\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\nimport {\n  DigitalAsset,\n  JsonMetadata,\n  fetchDigitalAsset,\n  fetchJsonMetadata,\n} from \"@metaplex-foundation/mpl-token-metadata\";\n\nconst updateLoadingText = (\n  loadingText,\n  guardList,\n  label,\n  setGuardList\n) => {\n  const guardIndex = guardList.findIndex((g) => g.label === label);\n  if (guardIndex === -1) {\n    console.error(\"guard not found\");\n    return;\n  }\n  const newGuardList = [...guardList];\n  newGuardList[guardIndex].loadingText = loadingText;\n  setGuardList(newGuardList);\n};\n\nconst fetchNft = async (\n  umi,\n  nftAddress\n) => {\n  let digitalAsset;\n  let jsonMetadata;\n  try {\n    digitalAsset = await fetchDigitalAsset(umi, nftAddress);\n    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\n  } catch (e) {\n    console.error(e);\n    notification.info({\n      message: \"NFT could not be fetched!\",\n      description: \"Please check your Wallet instead.\",\n      duration: 9,\n    });\n  }\n\n  return { digitalAsset, jsonMetadata };\n};\n\nconst mintClick = async (\n  umi,\n  guard,\n  candyMachine,\n  candyGuard,\n  ownedTokens,\n  mintAmount,\n  mintsCreated,\n  setMintsCreated,\n  guardList,\n  setGuardList,\n  onOpen,\n  setCheckEligibility\n) => {\n  const guardToUse = chooseGuardToUse(guard, candyGuard);\n  if (!guardToUse.guards) {\n    console.error(\"no guard defined!\");\n    return;\n  }\n\n  let buyBeer = true;\n  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER);\n\n  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\n    buyBeer = false;\n    console.log(\"The Creator does not want to pay for MarkSackerbergs beer ðŸ˜’\");\n  }\n\n  try {\n    // Find the guard by guardToUse.label and set minting to true\n    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n    if (guardIndex === -1) {\n      console.error(\"guard not found\");\n      return;\n    }\n    const newGuardList = [...guardList];\n    newGuardList[guardIndex].minting = true;\n    setGuardList(newGuardList);\n\n    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\n    if (routeBuild && routeBuild.items.length > 0) {\n      notification.info({\n        message: \"Allowlist detected. Please sign to be approved to mint.\",\n        duration: 9,\n      });\n      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\n      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\n      routeBuild = routeBuild.setBlockhash(latestBlockhash);\n      const builtTx = await routeBuild.buildAndSign(umi);\n      const sig = await umi.rpc\n        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n        .then((signature) => {\n          return { status: \"fulfilled\", value: signature };\n        })\n        .catch((error) => {\n          notification.error({\n            message: \"Allow List TX failed!\",\n            duration: 9,\n          });\n          return { status: \"rejected\", reason: error, value: new Uint8Array };\n        });\n\n      if (sig.status === \"fulfilled\")\n        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\n    }\n\n    // Fetch LUT\n    let tables = [];\n    const lut = process.env.NEXT_PUBLIC_LUT;\n    if (lut) {\n      const lutPubKey = publicKey(lut);\n      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\n      tables = [fetchedLut];\n    } else {\n      notification.warning({\n        message: \"The developer should really set a lookup table!\",\n        duration: 9,\n      });\n    }\n\n    const mintTxs = [];\n    let nftSigners = [];\n\n    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\n\n    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\n    const nftMint = generateSigner(umi);\n    const txForSimulation = buildTx(\n      umi,\n      candyMachine,\n      candyGuard,\n      nftMint,\n      guardToUse,\n      mintArgs,\n      tables,\n      latestBlockhash,\n      1_400_000,\n      buyBeer\n    );\n    const requiredCu = await getRequiredCU(umi, txForSimulation);\n\n    for (let i = 0; i < mintAmount; i++) {\n      const nftMint = generateSigner(umi);\n      nftSigners.push(nftMint);\n      const transaction = buildTx(\n        umi,\n        candyMachine,\n        candyGuard,\n        nftMint,\n        guardToUse,\n        mintArgs,\n        tables,\n        latestBlockhash,\n        requiredCu,\n        buyBeer\n      );\n      mintTxs.push(transaction);\n    }\n    if (!mintTxs.length) {\n      console.error(\"no mint tx built!\");\n      return;\n    }\n\n    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\n    const signedTransactions = await signAllTransactions(\n      mintTxs.map((transaction, index) => ({\n        transaction,\n        signers: [umi.payer, nftSigners[index]],\n      }))\n    );\n\n    let signatures = [];\n    let amountSent = 0;\n\n    const sendPromises = signedTransactions.map((tx, index) => {\n      return umi.rpc\n        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\n        .then((signature) => {\n          console.log(\n            `Transaction ${index + 1} resolved with signature: ${\n              base58.deserialize(signature)[0]\n            }`\n          );\n          amountSent += 1;\n          signatures.push(signature);\n          return { status: \"fulfilled\", value: signature };\n        })\n        .catch((error) => {\n          console.error(`Transaction ${index + 1} failed:`, error);\n          return { status: \"rejected\", reason: error };\n        });\n    });\n\n    await Promise.allSettled(sendPromises);\n\n    if (!(await sendPromises[0]).status === true) {\n      // throw error that no tx was created\n      throw new Error(\"no tx was created\");\n    }\n    updateLoadingText(\n      `finalizing transaction(s)`,\n      guardList,\n      guardToUse.label,\n      setGuardList\n    );\n\n    notification.success({\n      message: `${signedTransactions.length} Transaction(s) sent!`,\n      duration: 3,\n    });\n\n    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\n\n    updateLoadingText(\n      \"Fetching your NFT\",\n      guardList,\n      guardToUse.label,\n      setGuardList\n    );\n\n    // Filter out successful mints and map to fetch promises\n    const fetchNftPromises = successfulMints.map((mintResult) =>\n      fetchNft(umi, mintResult).then((nftData) => ({\n        mint: mintResult,\n        nftData,\n      }))\n    );\n\n    const fetchedNftsResults = await Promise.all(fetchNftPromises);\n\n    // Prepare data for setting mintsCreated\n    let newMintsCreated = [];\n    fetchedNftsResults.map((acc) => {\n      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\n        newMintsCreated.push({\n          mint: acc.mint,\n          offChainMetadata: acc.nftData.jsonMetadata,\n        });\n      }\n      return acc;\n    });\n\n    // Update mintsCreated only if there are new mints\n    if (newMintsCreated.length > 0) {\n      setMintsCreated(newMintsCreated);\n      onOpen();\n    }\n  } catch (e) {\n    console.error(`minting failed because of ${e}`);\n    notification.error({\n      message: \"Your mint failed!\",\n      description: \"Please try again.\",\n      duration: 9,\n    });\n  } finally {\n    // Find the guard by guardToUse.label and set minting to false\n    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\n    if (guardIndex === -1) {\n      console.error(\"guard not found\");\n      return;\n    }\n    const newGuardList = [...guardList];\n    newGuardList[guardIndex].minting = false;\n    setGuardList(newGuardList);\n    setCheckEligibility(true);\n    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\n  }\n};\n\n// Timer component\nconst Timer = ({\n  solanaTime,\n  toTime,\n  setCheckEligibility,\n}) => {\n  const [remainingTime, setRemainingTime] = useState(toTime - solanaTime);\n  useEffect(() => {\n    const interval = setInterval(() => {\n      setRemainingTime((prev) => prev - BigInt(1));\n    }, 1000);\n    return () => clearInterval(interval);\n  }, []);\n\n  const days = remainingTime / BigInt(86400);\n  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\n  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\n  const seconds = remainingTime % BigInt(60);\n  \n  if (days > BigInt(0)) {\n    return (\n      <Text>\n        {days.toString()} d {hours.toString()} h {minutes.toString()} m {seconds.toString()} s\n      </Text>\n    );\n  }\n  if (hours > BigInt(0)) {\n    return (\n      <Text>\n        {hours.toString()} h {minutes.toString()} m {seconds.toString()} s\n      </Text>\n    );\n  }\n  if (minutes > BigInt(0) || seconds > BigInt(0)) {\n    return (\n      <Text>\n        {minutes.toString()} m {seconds.toString()} s\n      </Text>\n    );\n  }\n  if (remainingTime === BigInt(0)) {\n    setCheckEligibility(true);\n  }\n  return <Text></Text>;\n};\n\nexport function ButtonList({\n  umi,\n  guardList,\n  candyMachine,\n  candyGuard,\n  ownedTokens = [],\n  setGuardList,\n  mintsCreated,\n  setMintsCreated,\n  onOpen,\n  setCheckEligibility,\n}) {\n  const solanaTime = useSolanaTime();\n  const [numberInputValues, setNumberInputValues] = useState({});\n\n  if (!candyMachine || !candyGuard) {\n    return <></>;\n  }\n\n  const handleNumberInputChange = (label, value) => {\n    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\n  };\n\n  let filteredGuardlist = guardList.filter(\n    (elem, index, self) =>\n      index === self.findIndex((t) => t.label === elem.label)\n  );\n\n  if (filteredGuardlist.length === 0) {\n    return <></>;\n  }\n\n  if (filteredGuardlist.length > 1) {\n    filteredGuardlist = guardList.filter((elem) => elem.label !== \"default\");\n  }\n\n  let buttonGuardList = [];\n  for (const guard of filteredGuardlist) {\n    const text = mintText.find((elem) => elem.label === guard.label);\n    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\n    let startTime = BigInt(0);\n    let endTime = BigInt(0);\n    if (group) {\n      if (group.guards.startDate.__option === \"Some\") {\n        startTime = group.guards.startDate.value.date;\n      }\n      if (group.guards.endDate.__option === \"Some\") {\n        endTime = group.guards.endDate.value.date;\n      }\n    }\n\n    let buttonElement = {\n      label: guard ? guard.label : \"default\",\n      allowed: guard.allowed,\n      header: text ? text.header : \"header missing in settings.tsx\",\n      mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\n      buttonLabel: text ? text.buttonLabel : \"buttonLabel missing in settings.tsx\",\n      startTime,\n      endTime,\n      tooltip: guard.reason,\n      maxAmount: guard.maxAmount,\n    };\n    buttonGuardList.push(buttonElement);\n  }\n\n  const listItems = buttonGuardList.map((buttonGuard, index) => (\n    <div key={index} style={{ marginTop: \"20px\" }}>\n      <Divider />\n      <Row>\n        <Col>\n          <Text strong>{buttonGuard.header}</Text>\n        </Col>\n        <Col style={{ textAlign: \"right\" }}>\n          {buttonGuard.endTime > BigInt(0) &&\n            buttonGuard.endTime - solanaTime > BigInt(0) &&\n            (!buttonGuard.startTime ||\n              buttonGuard.startTime - solanaTime <= BigInt(0)) && (\n              <>\n                <Text>Ending in: </Text>\n                <Timer\n                  toTime={buttonGuard.endTime}\n                  solanaTime={solanaTime}\n                  setCheckEligibility={setCheckEligibility}\n                />\n              </>\n            )}\n          {buttonGuard.startTime > BigInt(0) &&\n            buttonGuard.startTime - solanaTime > BigInt(0) &&\n            (!buttonGuard.endTime ||\n              solanaTime - buttonGuard.endTime <= BigInt(0)) && (\n              <>\n                <Text>Starting in: </Text>\n                <Timer\n                  toTime={buttonGuard.startTime}\n                  solanaTime={solanaTime}\n                  setCheckEligibility={setCheckEligibility}\n                />\n              </>\n            )}\n        </Col>\n      </Row>\n      <Row>\n        <Text>{buttonGuard.mintText}</Text>\n        <Col>\n          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\n            <InputNumber\n              value={numberInputValues[buttonGuard.label] || 1}\n              min={1}\n              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\n              onChange={(value) => handleNumberInputChange(buttonGuard.label, value)}\n            />\n          ) : null}\n\n          <Tooltip title={buttonGuard.tooltip}>\n            <Button\n              onClick={() =>\n                mintClick(\n                  umi,\n                  buttonGuard,\n                  candyMachine,\n                  candyGuard,\n                  ownedTokens,\n                  numberInputValues[buttonGuard.label] || 1,\n                  mintsCreated,\n                  setMintsCreated,\n                  guardList,\n                  setGuardList,\n                  onOpen,\n                  setCheckEligibility\n                )\n              }\n              key={buttonGuard.label}\n              type=\"primary\"\n              disabled={!buttonGuard.allowed}\n              loading={\n                guardList.find((elem) => elem.label === buttonGuard.label)\n                  ?.minting\n              }\n            >\n              {buttonGuard.buttonLabel}\n            </Button>\n          </Tooltip>\n        </Col>\n      </Row>\n    </div>\n  ));\n\n  return <>{listItems}</>;\n}"
        }
    ]
}