{
    "sourceFile": "pages/components/mintButton.tsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 43,
            "patches": [
                {
                    "date": 1731332300639,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731333131731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,8 +541,9 @@\n       maxAmount: guard.maxAmount,\r\n     };\r\n     buttonGuardList.push(buttonElement);\r\n     console.log(\"buttonGuardList:\", buttonGuardList); \r\n+    console.log(\"buttonGuard:\", buttonGuard); \r\n   }\r\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n     <Box key={index} marginTop={\"20px\"}>\r\n"
                },
                {
                    "date": 1731333248297,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -541,9 +541,8 @@\n       maxAmount: guard.maxAmount,\r\n     };\r\n     buttonGuardList.push(buttonElement);\r\n     console.log(\"buttonGuardList:\", buttonGuardList); \r\n-    console.log(\"buttonGuard:\", buttonGuard); \r\n   }\r\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n     <Box key={index} marginTop={\"20px\"}>\r\n"
                },
                {
                    "date": 1731333283829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,660 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              isDisabled={buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              isDisabled={!buttonGuard.allowed}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731333310427,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,660 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              isDisabled={buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              isDisabled={!buttonGuard.allowed}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731333343894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,668 +566,8 @@\n                   setCheckEligibility={setCheckEligibility}\r\n                 />\r\n               </>\r\n             )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              isDisabled={buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n           {buttonGuard.startTime > createBigInt(0) &&\r\n             buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n             (!buttonGuard.endTime ||\r\n               solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n@@ -1254,669 +594,9 @@\n               value={numberInputValues[buttonGuard.label] || 1}\r\n               min={1}\r\n               max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n               size=\"sm\"\r\n-              isDisabled={buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n               isDisabled={!buttonGuard.allowed}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n               onChange={(valueAsString, valueAsNumber) =>\r\n                 handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n               }\r\n             >\r\n"
                },
                {
                    "date": 1731334299569,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,660 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {buttonGuard.startTime < createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              isDisabled={!buttonGuard.allowed}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334346940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,668 +566,8 @@\n                   setCheckEligibility={setCheckEligibility}\r\n                 />\r\n               </>\r\n             )}\r\n-          {buttonGuard.startTime < createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n           {buttonGuard.startTime > createBigInt(0) &&\r\n             buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n             (!buttonGuard.endTime ||\r\n               solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n"
                },
                {
                    "date": 1731334360188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,658 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334530238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,622 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      \r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334556696,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,596 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      \r\n+      <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334584220,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -546,9 +546,9 @@\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n     <Box key={index} marginTop={\"20px\"}>\r\n       \r\n-      <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+ \r\n             <Button\r\n               onClick={() =>\r\n                 mintClick(\r\n                   umi,\r\n@@ -578,9 +578,9 @@\n               }\r\n             >\r\n               {buttonGuard.buttonLabel}\r\n             </Button>\r\n-          </Tooltip>\r\n+ \r\n     </Box>\r\n   ));\r\n \r\n   return <>{listItems}</>;\r\n@@ -592,1945 +592,5 @@\n     </div>\r\n   );\r\n };\r\n \r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      \r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334789885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -565,9 +565,9 @@\n                   setCheckEligibility\r\n                 )\r\n               }\r\n               key={buttonGuard.label}\r\n-              size=\"sm\"\r\n+              size=\"lg\"\r\n               backgroundColor=\"teal.100\"\r\n               isLoading={\r\n                 guardList.find((elem) => elem.label === buttonGuard.label)\r\n                   ?.minting\r\n"
                },
                {
                    "date": 1731334815883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -565,9 +565,10 @@\n                   setCheckEligibility\r\n                 )\r\n               }\r\n               key={buttonGuard.label}\r\n-              size=\"lg\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n               backgroundColor=\"teal.100\"\r\n               isLoading={\r\n                 guardList.find((elem) => elem.label === buttonGuard.label)\r\n                   ?.minting\r\n"
                },
                {
                    "date": 1731334842426,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -545,10 +545,72 @@\n   }\r\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n     <Box key={index} marginTop={\"20px\"}>\r\n-      \r\n- \r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              width=\"150px\" // 自定义宽度\r\n+  height=\"50px\" // 自定义高度\r\n+              isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n             <Button\r\n               onClick={() =>\r\n                 mintClick(\r\n                   umi,\r\n@@ -565,11 +627,11 @@\n                   setCheckEligibility\r\n                 )\r\n               }\r\n               key={buttonGuard.label}\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n+              size=\"sm\"\r\n               backgroundColor=\"teal.100\"\r\n+              isDisabled={!buttonGuard.allowed}\r\n               isLoading={\r\n                 guardList.find((elem) => elem.label === buttonGuard.label)\r\n                   ?.minting\r\n               }\r\n@@ -579,9 +641,11 @@\n               }\r\n             >\r\n               {buttonGuard.buttonLabel}\r\n             </Button>\r\n- \r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n     </Box>\r\n   ));\r\n \r\n   return <>{listItems}</>;\r\n"
                },
                {
                    "date": 1731334861320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -594,10 +594,9 @@\n               value={numberInputValues[buttonGuard.label] || 1}\r\n               min={1}\r\n               max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n               width=\"150px\" // 自定义宽度\r\n-  height=\"50px\" // 自定义高度\r\n-              isDisabled={!buttonGuard.allowed}\r\n+              height=\"50px\" // 自定义高度\r\n               onChange={(valueAsString, valueAsNumber) =>\r\n                 handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n               }\r\n             >\r\n"
                },
                {
                    "date": 1731334876150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,661 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n+          </Tooltip>\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334901940,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -584,9 +584,9 @@\n             )}\r\n         </Flex>\r\n       </HStack>\r\n       <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n+        <Text pt=\"2\" fontSize=\"lg\">\r\n           {buttonGuard.mintText}\r\n         </Text>\r\n         <VStack>\r\n           {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n@@ -657,665 +657,5 @@\n     </div>\r\n   );\r\n };\r\n \r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              isDisabled={!buttonGuard.allowed}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n-          </Tooltip>\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731334942325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -584,19 +584,18 @@\n             )}\r\n         </Flex>\r\n       </HStack>\r\n       <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"lg\">\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n           {buttonGuard.mintText}\r\n         </Text>\r\n         <VStack>\r\n           {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n             <NumberInput\r\n               value={numberInputValues[buttonGuard.label] || 1}\r\n               min={1}\r\n               max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n+              size=\"sm\"\r\n               // isDisabled={!buttonGuard.allowed}\r\n               onChange={(valueAsString, valueAsNumber) =>\r\n                 handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n               }\r\n@@ -627,9 +626,11 @@\n                   setCheckEligibility\r\n                 )\r\n               }\r\n               key={buttonGuard.label}\r\n-              size=\"sm\"\r\n+              // size=\"sm\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n               backgroundColor=\"teal.100\"\r\n               // isDisabled={!buttonGuard.allowed}\r\n               isLoading={\r\n                 guardList.find((elem) => elem.label === buttonGuard.label)\r\n"
                },
                {
                    "date": 1731335447376,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -540,9 +540,9 @@\n       tooltip: guard.reason,\r\n       maxAmount: guard.maxAmount,\r\n     };\r\n     buttonGuardList.push(buttonElement);\r\n-    console.log(\"buttonGuardList:\", buttonGuardList); \r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n   }\r\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n     <Box key={index} marginTop={\"20px\"}>\r\n@@ -607,9 +607,9 @@\n               </NumberInputStepper>\r\n             </NumberInput>\r\n           ) : null}\r\n \r\n-          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n             <Button\r\n               onClick={() =>\r\n                 mintClick(\r\n                   umi,\r\n@@ -642,9 +642,9 @@\n               }\r\n             >\r\n               {buttonGuard.buttonLabel}\r\n             </Button>\r\n-          </Tooltip>\r\n+          {/* </Tooltip> */}\r\n         </VStack>\r\n       </SimpleGrid>\r\n     </Box>\r\n   ));\r\n"
                },
                {
                    "date": 1731335464457,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -566,9 +566,9 @@\n                   setCheckEligibility={setCheckEligibility}\r\n                 />\r\n               </>\r\n             )}\r\n-          {buttonGuard.startTime > createBigInt(0) &&\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n             buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n             (!buttonGuard.endTime ||\r\n               solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n               <>\r\n@@ -580,9 +580,9 @@\n                   solanaTime={solanaTime}\r\n                   setCheckEligibility={setCheckEligibility}\r\n                 />\r\n               </>\r\n-            )}\r\n+            )} */}\r\n         </Flex>\r\n       </HStack>\r\n       <SimpleGrid columns={2} spacing={5}>\r\n         <Text pt=\"2\" fontSize=\"sm\">\r\n"
                },
                {
                    "date": 1731335671799,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,42 +608,40 @@\n             </NumberInput>\r\n           ) : null}\r\n \r\n           {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              {buttonGuard.buttonLabel}\r\n-            </Button>\r\n+          <Button\r\n+  onClick={canMint && disableMint ? () =>\r\n+    mintClick(\r\n+      umi,\r\n+      buttonGuard,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      ownedTokens,\r\n+      numberInputValues[buttonGuard.label] || 1,\r\n+      mintsCreated,\r\n+      setMintsCreated,\r\n+      guardList,\r\n+      setGuardList,\r\n+      onOpen,\r\n+      setCheckEligibility\r\n+    ) : null} // 当 canMint 为 true 且 disableMint 为 false 时，点击事件为 mintClick\r\n+  disabled={!canMint || !disableMint} // 根据 canMint 和 disableMint 设置按钮禁用状态\r\n+  className={`mint-button ${!disableMint ? 'disabled' : ''}`} // 根据 disableMint 设置类名\r\n+  width=\"150px\" // 自定义宽度\r\n+  height=\"50px\" // 自定义高度\r\n+  backgroundColor=\"teal.100\"\r\n+  isLoading={\r\n+    guardList.find((elem) => elem.label === buttonGuard.label)\r\n+      ?.minting\r\n+  }\r\n+  loadingText={\r\n+    guardList.find((elem) => elem.label === buttonGuard.label)\r\n+      ?.loadingText\r\n+  }\r\n+>\r\n+  {buttonGuard.buttonLabel}\r\n+</Button>\r\n           {/* </Tooltip> */}\r\n         </VStack>\r\n       </SimpleGrid>\r\n     </Box>\r\n"
                },
                {
                    "date": 1731335712258,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -608,40 +608,43 @@\n             </NumberInput>\r\n           ) : null}\r\n \r\n           {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-  onClick={canMint && disableMint ? () =>\r\n-    mintClick(\r\n-      umi,\r\n-      buttonGuard,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      ownedTokens,\r\n-      numberInputValues[buttonGuard.label] || 1,\r\n-      mintsCreated,\r\n-      setMintsCreated,\r\n-      guardList,\r\n-      setGuardList,\r\n-      onOpen,\r\n-      setCheckEligibility\r\n-    ) : null} // 当 canMint 为 true 且 disableMint 为 false 时，点击事件为 mintClick\r\n-  disabled={!canMint || !disableMint} // 根据 canMint 和 disableMint 设置按钮禁用状态\r\n-  className={`mint-button ${!disableMint ? 'disabled' : ''}`} // 根据 disableMint 设置类名\r\n-  width=\"150px\" // 自定义宽度\r\n-  height=\"50px\" // 自定义高度\r\n-  backgroundColor=\"teal.100\"\r\n-  isLoading={\r\n-    guardList.find((elem) => elem.label === buttonGuard.label)\r\n-      ?.minting\r\n-  }\r\n-  loadingText={\r\n-    guardList.find((elem) => elem.label === buttonGuard.label)\r\n-      ?.loadingText\r\n-  }\r\n->\r\n-  {buttonGuard.buttonLabel}\r\n-</Button>\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              // size=\"sm\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              className={'mint-button'}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              {buttonGuard.buttonLabel}\r\n+            </Button>\r\n           {/* </Tooltip> */}\r\n         </VStack>\r\n       </SimpleGrid>\r\n     </Box>\r\n"
                },
                {
                    "date": 1731335787914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,8 +60,9 @@\n } from \"../utils/mintHelper\";\r\n import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n import { verifyTx } from \".././utils/verifyTx\";\r\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n \r\n const updateLoadingText = (\r\n   loadingText: string | undefined,\r\n   guardList: GuardReturn[],\r\n@@ -641,9 +642,10 @@\n                 guardList.find((elem) => elem.label === buttonGuard.label)\r\n                   ?.loadingText\r\n               }\r\n             >\r\n-              {buttonGuard.buttonLabel}\r\n+              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n+              {/* {buttonGuard.buttonLabel} */}\r\n             </Button>\r\n           {/* </Tooltip> */}\r\n         </VStack>\r\n       </SimpleGrid>\r\n"
                },
                {
                    "date": 1731336455079,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,670 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+\r\n+    updateLoadingText(\r\n+      <FormattedMessage id=\"pleaseSign\" defaultMessage=\"Please sign\" />,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              // size=\"sm\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              className={'mint-button'}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n+              {/* {buttonGuard.buttonLabel} */}\r\n+            </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731336503792,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,9 +63,9 @@\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n import { FormattedMessage } from 'react-intl';\r\n \r\n const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n+  loadingText: React.ReactNode | undefined, // 修改这里\r\n   guardList: GuardReturn[],\r\n   label: string,\r\n   setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n ) => {\r\n"
                },
                {
                    "date": 1731336595042,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -63,678 +63,8 @@\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n import { FormattedMessage } from 'react-intl';\r\n \r\n const updateLoadingText = (\r\n-  loadingText: React.ReactNode | undefined, // 修改这里\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-\r\n-    updateLoadingText(\r\n-      <FormattedMessage id=\"pleaseSign\" defaultMessage=\"Please sign\" />,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              className={'mint-button'}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n-              {/* {buttonGuard.buttonLabel} */}\r\n-            </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-\r\n-const updateLoadingText = (\r\n   loadingText: string | undefined,\r\n   guardList: GuardReturn[],\r\n   label: string,\r\n   setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n"
                },
                {
                    "date": 1731336907682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,8 +61,9 @@\n import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n import { verifyTx } from \".././utils/verifyTx\";\r\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n \r\n const updateLoadingText = (\r\n   loadingText: string | undefined,\r\n   guardList: GuardReturn[],\r\n@@ -241,10 +242,16 @@\n     if (!mintTxs.length) {\r\n       console.error(\"no mint tx built!\");\r\n       return;\r\n     }\r\n-\r\n-    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n+  // 获取当前语言的 \"sign\" 文本\r\n+  const signText = messages[language].sign;\r\n+    updateLoadingText(\r\n+      <FormattedMessage id=\"pleaseSign\" defaultMessage=\"Please sign\" />,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n     const signedTransactions = await signAllTransactions(\r\n       mintTxs.map((transaction, index) => ({\r\n         transaction,\r\n         signers: [umi.payer, nftsigners[index]],\r\n"
                },
                {
                    "date": 1731336970306,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -242,12 +242,13 @@\n     if (!mintTxs.length) {\r\n       console.error(\"no mint tx built!\");\r\n       return;\r\n     }\r\n-  // 获取当前语言的 \"sign\" 文本\r\n-  const signText = messages[language].sign;\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages[language].sign;\r\n+\r\n     updateLoadingText(\r\n-      <FormattedMessage id=\"pleaseSign\" defaultMessage=\"Please sign\" />,\r\n+      signText,\r\n       guardList,\r\n       guardToUse.label,\r\n       setGuardList\r\n     );\r\n"
                },
                {
                    "date": 1731337787158,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,673 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              // size=\"sm\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              className={'mint-button'}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n+              {/* {buttonGuard.buttonLabel} */}\r\n+            </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731337810206,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,673 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              // size=\"sm\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              className={'mint-button'}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n+              {/* {buttonGuard.buttonLabel} */}\r\n+            </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731337821870,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -553,9 +553,9 @@\n     // console.log(\"buttonGuardList:\", buttonGuardList); \r\n   }\r\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n+    <Box key={index} marginTop={\"20px\"}>\r\n       <Divider my=\"10px\" />\r\n       <HStack>\r\n         <Heading size=\"xs\" textTransform=\"uppercase\">\r\n           {buttonGuard.header}\r\n"
                },
                {
                    "date": 1731337852300,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,674 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      `finalizing transaction(s)`,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              // size=\"sm\"\r\n+              width=\"150px\" // 自定义宽度\r\n+              height=\"50px\" // 自定义高度\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              className={'mint-button'}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+               <FormattedMessage id={'mint'} />\r\n+              {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+              {/* {buttonGuard.buttonLabel} */}\r\n+            </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731337926778,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -636,10 +636,10 @@\n                 )\r\n               }\r\n               key={buttonGuard.label}\r\n               // size=\"sm\"\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n+              width=\"200px\" // 自定义宽度\r\n+              height=\"100px\" // 自定义高度\r\n               backgroundColor=\"teal.100\"\r\n               // isDisabled={!buttonGuard.allowed}\r\n               className={'mint-button'}\r\n               isLoading={\r\n@@ -670,2024 +670,5 @@\n     </div>\r\n   );\r\n };\r\n \r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              className={'mint-button'}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n-              {/* {buttonGuard.buttonLabel} */}\r\n-            </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              className={'mint-button'}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n-              {/* {buttonGuard.buttonLabel} */}\r\n-            </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages[language].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} marginTop={\"20px\"}>\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              width=\"150px\" // 自定义宽度\r\n-              height=\"50px\" // 自定义高度\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              className={'mint-button'}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-              <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} />\r\n-              {/* {buttonGuard.buttonLabel} */}\r\n-            </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731337952873,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -636,10 +636,8 @@\n                 )\r\n               }\r\n               key={buttonGuard.label}\r\n               // size=\"sm\"\r\n-              width=\"200px\" // 自定义宽度\r\n-              height=\"100px\" // 自定义高度\r\n               backgroundColor=\"teal.100\"\r\n               // isDisabled={!buttonGuard.allowed}\r\n               className={'mint-button'}\r\n               isLoading={\r\n"
                },
                {
                    "date": 1731338426675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,672 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      <Divider my=\"10px\" />\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text>\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+            <Button\r\n+              onClick={() =>\r\n+                mintClick(\r\n+                  umi,\r\n+                  buttonGuard,\r\n+                  candyMachine,\r\n+                  candyGuard,\r\n+                  ownedTokens,\r\n+                  numberInputValues[buttonGuard.label] || 1,\r\n+                  mintsCreated,\r\n+                  setMintsCreated,\r\n+                  guardList,\r\n+                  setGuardList,\r\n+                  onOpen,\r\n+                  setCheckEligibility\r\n+                )\r\n+              }\r\n+              key={buttonGuard.label}\r\n+              // size=\"sm\"\r\n+              backgroundColor=\"teal.100\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              className={'mint-button'}\r\n+              isLoading={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.minting\r\n+              }\r\n+              loadingText={\r\n+                guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                  ?.loadingText\r\n+              }\r\n+            >\r\n+               <FormattedMessage id={'mint'} />\r\n+              {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+              {/* {buttonGuard.buttonLabel} */}\r\n+            </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731596925431,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -554,9 +554,9 @@\n   }\r\n \r\n   const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n     <Box key={index} >\r\n-      <Divider my=\"10px\" />\r\n+      {/* <Divider my=\"10px\" /> */}\r\n       <HStack>\r\n         <Heading size=\"xs\" textTransform=\"uppercase\">\r\n           {buttonGuard.header}\r\n         </Heading>\r\n@@ -593,11 +593,11 @@\n             )} */}\r\n         </Flex>\r\n       </HStack>\r\n       <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n           {buttonGuard.mintText}\r\n-        </Text>\r\n+        </Text> */}\r\n         <VStack>\r\n           {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n             <NumberInput\r\n               value={numberInputValues[buttonGuard.label] || 1}\r\n@@ -617,43 +617,42 @@\n             </NumberInput>\r\n           ) : null}\r\n \r\n           {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              className={'mint-button'}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-               <FormattedMessage id={'mint'} />\r\n-              {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-              {/* {buttonGuard.buttonLabel} */}\r\n-            </Button>\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            backgroundColor=\"teal.100\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n           {/* </Tooltip> */}\r\n         </VStack>\r\n       </SimpleGrid>\r\n     </Box>\r\n@@ -668,677 +667,5 @@\n     </div>\r\n   );\r\n };\r\n \r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      `finalizing transaction(s)`,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      <Divider my=\"10px\" />\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text>\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-            <Button\r\n-              onClick={() =>\r\n-                mintClick(\r\n-                  umi,\r\n-                  buttonGuard,\r\n-                  candyMachine,\r\n-                  candyGuard,\r\n-                  ownedTokens,\r\n-                  numberInputValues[buttonGuard.label] || 1,\r\n-                  mintsCreated,\r\n-                  setMintsCreated,\r\n-                  guardList,\r\n-                  setGuardList,\r\n-                  onOpen,\r\n-                  setCheckEligibility\r\n-                )\r\n-              }\r\n-              key={buttonGuard.label}\r\n-              // size=\"sm\"\r\n-              backgroundColor=\"teal.100\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              className={'mint-button'}\r\n-              isLoading={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.minting\r\n-              }\r\n-              loadingText={\r\n-                guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                  ?.loadingText\r\n-              }\r\n-            >\r\n-               <FormattedMessage id={'mint'} />\r\n-              {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-              {/* {buttonGuard.buttonLabel} */}\r\n-            </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731596935277,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,672 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      {/* <Divider my=\"10px\" /> */}\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text> */}\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            backgroundColor=\"teal.100\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            className={'mint-button'}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731597669145,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,671 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      {/* <Divider my=\"10px\" /> */}\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text> */}\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            className={'mint-button'}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731597687882,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,672 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      {/* <Divider my=\"10px\" /> */}\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text> */}\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            backgroundColor=\"teal.100\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            className={'mint-button'}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731606044183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,675 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+import { useWallet } from \"@solana/wallet-adapter-react\";\r\n+\r\n+const { connected, connect } = useWallet(); // 获取连接状态和连接函数\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      {/* <Divider my=\"10px\" /> */}\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text> */}\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            backgroundColor=\"teal.100\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            className={'mint-button'}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731607602898,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,723 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+import { useWallet } from \"@solana/wallet-adapter-react\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+export function handleButtonClickFunt({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [],\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const { connected, connect } = useWallet(); // 获取连接状态和连接函数\r\n+\r\n+  const handleButtonClick = async () => {\r\n+    if (!connected) {\r\n+      // 如果钱包未连接，调用连接函数\r\n+      await connect();\r\n+    } else {\r\n+      // 如果钱包已连接，执行铸造逻辑\r\n+      mintClick(\r\n+        umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+      );\r\n+    }\r\n+  };\r\n+\r\n+  return (\r\n+    <Button\r\n+      onClick={handleButtonClick}\r\n+      className={'mint-button'}\r\n+      isLoading={guardList.find((elem) => elem.label === guard.label)?.minting}\r\n+      loadingText={guardList.find((elem) => elem.label === guard.label)?.loadingText}\r\n+      backgroundColor=\"teal.100\"\r\n+    >\r\n+      <FormattedMessage id={'mint'} />\r\n+    </Button>\r\n+  );\r\n+}\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      {/* <Divider my=\"10px\" /> */}\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text> */}\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            backgroundColor=\"teal.100\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            className={'mint-button'}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731607704102,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,673 @@\n+import {\r\n+  CandyGuard,\r\n+  CandyMachine,\r\n+  mintV2,\r\n+} from \"@metaplex-foundation/mpl-candy-machine\";\r\n+import { GuardReturn } from \".././utils/checkerHelper\";\r\n+import {\r\n+  AddressLookupTableInput,\r\n+  KeypairSigner,\r\n+  PublicKey,\r\n+  Transaction,\r\n+  Umi,\r\n+  createBigInt,\r\n+  generateSigner,\r\n+  none,\r\n+  publicKey,\r\n+  signAllTransactions,\r\n+  signTransaction,\r\n+  sol,\r\n+  some,\r\n+  transactionBuilder,\r\n+} from \"@metaplex-foundation/umi\";\r\n+import {\r\n+  DigitalAsset,\r\n+  DigitalAssetWithToken,\r\n+  JsonMetadata,\r\n+  fetchDigitalAsset,\r\n+  fetchJsonMetadata,\r\n+} from \"@metaplex-foundation/mpl-token-metadata\";\r\n+import { mintText } from \".././settings\";\r\n+import {\r\n+  Box,\r\n+  Button,\r\n+  Flex,\r\n+  HStack,\r\n+  Heading,\r\n+  SimpleGrid,\r\n+  Text,\r\n+  Tooltip,\r\n+  NumberInput,\r\n+  NumberInputField,\r\n+  NumberInputStepper,\r\n+  NumberIncrementStepper,\r\n+  NumberDecrementStepper,\r\n+  VStack,\r\n+  Divider,\r\n+  createStandaloneToast,\r\n+} from \"@chakra-ui/react\";\r\n+import {\r\n+  fetchAddressLookupTable, setComputeUnitPrice,\r\n+} from \"@metaplex-foundation/mpl-toolbox\";\r\n+import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n+import {\r\n+  chooseGuardToUse,\r\n+  routeBuilder,\r\n+  mintArgsBuilder,\r\n+  GuardButtonList,\r\n+  buildTx,\r\n+  getRequiredCU,\r\n+} from \"../utils/mintHelper\";\r\n+import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n+import { verifyTx } from \".././utils/verifyTx\";\r\n+import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n+import { FormattedMessage } from 'react-intl';\r\n+import { messages } from '.././locales';\r\n+import { useWallet } from \"@solana/wallet-adapter-react\";\r\n+\r\n+const updateLoadingText = (\r\n+  loadingText: string | undefined,\r\n+  guardList: GuardReturn[],\r\n+  label: string,\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n+) => {\r\n+  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n+  if (guardIndex === -1) {\r\n+    console.error(\"guard not found\");\r\n+    return;\r\n+  }\r\n+  const newGuardList = [...guardList];\r\n+  newGuardList[guardIndex].loadingText = loadingText;\r\n+  setGuardList(newGuardList);\r\n+};\r\n+\r\n+const fetchNft = async (\r\n+  umi: Umi,\r\n+  nftAdress: PublicKey,\r\n+) => {\r\n+  let digitalAsset: DigitalAsset | undefined;\r\n+  let jsonMetadata: JsonMetadata | undefined;\r\n+  try {\r\n+    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n+    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n+  } catch (e) {\r\n+    console.error(e);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Nft could not be fetched!\",\r\n+      description: \"Please check your Wallet instead.\",\r\n+      status: \"info\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  }\r\n+\r\n+  return { digitalAsset, jsonMetadata };\r\n+};\r\n+\r\n+const mintClick = async (\r\n+  umi: Umi,\r\n+  guard: GuardReturn,\r\n+  candyMachine: CandyMachine,\r\n+  candyGuard: CandyGuard,\r\n+  ownedTokens: DigitalAssetWithToken[],\r\n+  mintAmount: number,\r\n+  mintsCreated:\r\n+    | {\r\n+      mint: PublicKey;\r\n+      offChainMetadata: JsonMetadata | undefined;\r\n+    }[]\r\n+    | undefined,\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >,\r\n+  guardList: GuardReturn[],\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n+  onOpen: () => void,\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n+) => {\r\n+  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n+  if (!guardToUse.guards) {\r\n+    console.error(\"no guard defined!\");\r\n+    return;\r\n+  }\r\n+\r\n+  let buyBeer = false;\r\n+  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n+\r\n+  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n+    buyBeer = false;\r\n+    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n+  }\r\n+\r\n+  try {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = true;\r\n+    setGuardList(newGuardList);\r\n+\r\n+    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n+    if (routeBuild && routeBuild.items.length > 0) {\r\n+      createStandaloneToast().toast({\r\n+        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n+        status: \"info\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n+      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n+      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n+      const builtTx = await routeBuild.buildAndSign(umi);\r\n+      const sig = await umi.rpc\r\n+        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          createStandaloneToast().toast({\r\n+            title: \"Allow List TX failed!\",\r\n+            status: \"error\",\r\n+            duration: 900,\r\n+            isClosable: true,\r\n+          });\r\n+          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n+\r\n+        });\r\n+      if (sig.status === \"fulfilled\")\r\n+        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n+\r\n+    }\r\n+\r\n+    // fetch LUT\r\n+    let tables: AddressLookupTableInput[] = [];\r\n+    const lut = process.env.NEXT_PUBLIC_LUT;\r\n+    if (lut) {\r\n+      const lutPubKey = publicKey(lut);\r\n+      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n+      tables = [fetchedLut];\r\n+    } else {\r\n+      createStandaloneToast().toast({\r\n+        title: \"The developer should really set a lookup table!\",\r\n+        status: \"warning\",\r\n+        duration: 900,\r\n+        isClosable: true,\r\n+      });\r\n+    }\r\n+\r\n+    const mintTxs: Transaction[] = [];\r\n+    let nftsigners = [] as KeypairSigner[];\r\n+\r\n+    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n+\r\n+    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n+    const nftMint = generateSigner(umi);\r\n+    const txForSimulation = buildTx(\r\n+      umi,\r\n+      candyMachine,\r\n+      candyGuard,\r\n+      nftMint,\r\n+      guardToUse,\r\n+      mintArgs,\r\n+      tables,\r\n+      latestBlockhash,\r\n+      1_400_000,\r\n+      buyBeer\r\n+    );\r\n+    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n+\r\n+    for (let i = 0; i < mintAmount; i++) {\r\n+      const nftMint = generateSigner(umi);\r\n+      nftsigners.push(nftMint);\r\n+      const transaction = buildTx(\r\n+        umi,\r\n+        candyMachine,\r\n+        candyGuard,\r\n+        nftMint,\r\n+        guardToUse,\r\n+        mintArgs,\r\n+        tables,\r\n+        latestBlockhash,\r\n+        requiredCu,\r\n+        buyBeer\r\n+      );\r\n+      console.log(transaction)\r\n+      mintTxs.push(transaction);\r\n+    }\r\n+    if (!mintTxs.length) {\r\n+      console.error(\"no mint tx built!\");\r\n+      return;\r\n+    }\r\n+    // 获取当前语言的 \"sign\" 文本\r\n+    const signText = messages['en'].sign;\r\n+\r\n+    updateLoadingText(\r\n+      signText,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+    const signedTransactions = await signAllTransactions(\r\n+      mintTxs.map((transaction, index) => ({\r\n+        transaction,\r\n+        signers: [umi.payer, nftsigners[index]],\r\n+      }))\r\n+    );\r\n+\r\n+    let signatures: Uint8Array[] = [];\r\n+    let amountSent = 0;\r\n+\r\n+    const sendPromises = signedTransactions.map((tx, index) => {\r\n+      return umi.rpc\r\n+        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n+        .then((signature) => {\r\n+          console.log(\r\n+            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n+            }`\r\n+          );\r\n+          amountSent = amountSent + 1;\r\n+          signatures.push(signature);\r\n+          return { status: \"fulfilled\", value: signature };\r\n+        })\r\n+        .catch((error) => {\r\n+          console.error(`Transaction ${index + 1} failed:`, error);\r\n+          return { status: \"rejected\", reason: error };\r\n+        });\r\n+    });\r\n+\r\n+    await Promise.allSettled(sendPromises);\r\n+\r\n+    if (!(await sendPromises[0]).status === true) {\r\n+      // throw error that no tx was created\r\n+      throw new Error(\"no tx was created\");\r\n+    }\r\n+    updateLoadingText(\r\n+      ``,\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    createStandaloneToast().toast({\r\n+      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n+      status: \"success\",\r\n+      duration: 3000,\r\n+    });\r\n+\r\n+    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n+\r\n+    updateLoadingText(\r\n+      \"Fetching your NFT\",\r\n+      guardList,\r\n+      guardToUse.label,\r\n+      setGuardList\r\n+    );\r\n+\r\n+    // Filter out successful mints and map to fetch promises\r\n+    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n+      fetchNft(umi, mintResult).then((nftData) => ({\r\n+        mint: mintResult,\r\n+        nftData,\r\n+      }))\r\n+    );\r\n+\r\n+    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n+\r\n+    // Prepare data for setting mintsCreated\r\n+    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n+      [];\r\n+    fetchedNftsResults.map((acc) => {\r\n+      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n+        newMintsCreated.push({\r\n+          mint: acc.mint,\r\n+          offChainMetadata: acc.nftData.jsonMetadata,\r\n+        });\r\n+      }\r\n+      return acc;\r\n+    }, []);\r\n+\r\n+    // Update mintsCreated only if there are new mints\r\n+    if (newMintsCreated.length > 0) {\r\n+      setMintsCreated(newMintsCreated);\r\n+      onOpen();\r\n+    }\r\n+  } catch (e) {\r\n+    console.error(`minting failed because of ${e}`);\r\n+    createStandaloneToast().toast({\r\n+      title: \"Your mint failed!\",\r\n+      description: \"Please try again.\",\r\n+      status: \"error\",\r\n+      duration: 900,\r\n+      isClosable: true,\r\n+    });\r\n+  } finally {\r\n+    //find the guard by guardToUse.label and set minting to true\r\n+    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n+    if (guardIndex === -1) {\r\n+      console.error(\"guard not found\");\r\n+      return;\r\n+    }\r\n+    const newGuardList = [...guardList];\r\n+    newGuardList[guardIndex].minting = false;\r\n+    setGuardList(newGuardList);\r\n+    setCheckEligibility(true);\r\n+    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n+  }\r\n+};\r\n+// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n+const Timer = ({\r\n+  solanaTime,\r\n+  toTime,\r\n+  setCheckEligibility,\r\n+}: {\r\n+  solanaTime: bigint;\r\n+  toTime: bigint;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+}) => {\r\n+  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n+    toTime - solanaTime\r\n+  );\r\n+  useEffect(() => {\r\n+    const interval = setInterval(() => {\r\n+      setRemainingTime((prev) => {\r\n+        return prev - BigInt(1);\r\n+      });\r\n+    }, 1000);\r\n+    return () => clearInterval(interval);\r\n+  }, []);\r\n+\r\n+  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n+  const days = remainingTime / BigInt(86400);\r\n+  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n+  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n+  const seconds = remainingTime % BigInt(60);\r\n+  if (days > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {days.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        d{\" \"}\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (hours > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {hours.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        h{\" \"}\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n+    return (\r\n+      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n+        {minutes.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        m{\" \"}\r\n+        {seconds.toLocaleString(\"en-US\", {\r\n+          minimumIntegerDigits: 2,\r\n+          useGrouping: false,\r\n+        })}\r\n+        s\r\n+      </Text>\r\n+    );\r\n+  }\r\n+  if (remainingTime === BigInt(0)) {\r\n+    setCheckEligibility(true);\r\n+  }\r\n+  return <Text></Text>;\r\n+};\r\n+\r\n+type Props = {\r\n+  umi: Umi;\r\n+  guardList: GuardReturn[];\r\n+  candyMachine: CandyMachine | undefined;\r\n+  candyGuard: CandyGuard | undefined;\r\n+  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n+  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n+  mintsCreated:\r\n+  | {\r\n+    mint: PublicKey;\r\n+    offChainMetadata: JsonMetadata | undefined;\r\n+  }[]\r\n+  | undefined;\r\n+  setMintsCreated: Dispatch<\r\n+    SetStateAction<\r\n+      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n+      | undefined\r\n+    >\r\n+  >;\r\n+  onOpen: () => void;\r\n+  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n+};\r\n+\r\n+export function ButtonList({\r\n+  umi,\r\n+  guardList,\r\n+  candyMachine,\r\n+  candyGuard,\r\n+  ownedTokens = [], // provide default empty array\r\n+  setGuardList,\r\n+  mintsCreated,\r\n+  setMintsCreated,\r\n+  onOpen,\r\n+  setCheckEligibility,\r\n+}: Props): JSX.Element {\r\n+  const solanaTime = useSolanaTime();\r\n+  const [numberInputValues, setNumberInputValues] = useState<{\r\n+    [label: string]: number;\r\n+  }>({});\r\n+  if (!candyMachine || !candyGuard) {\r\n+    return <></>;\r\n+  }\r\n+\r\n+  const handleNumberInputChange = (label: string, value: number) => {\r\n+    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n+  };\r\n+\r\n+  // remove duplicates from guardList\r\n+  //fucked up bugfix\r\n+  let filteredGuardlist = guardList.filter(\r\n+    (elem, index, self) =>\r\n+      index === self.findIndex((t) => t.label === elem.label)\r\n+  );\r\n+  if (filteredGuardlist.length === 0) {\r\n+    return <></>;\r\n+  }\r\n+  // Guard \"default\" can only be used to mint in case no other guard exists\r\n+  if (filteredGuardlist.length > 1) {\r\n+    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n+  }\r\n+  let buttonGuardList = [];\r\n+  for (const guard of filteredGuardlist) {\r\n+    const text = mintText.find((elem) => elem.label === guard.label);\r\n+    // find guard by label in candyGuard\r\n+    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n+    let startTime = createBigInt(0);\r\n+    let endTime = createBigInt(0);\r\n+    if (group) {\r\n+      if (group.guards.startDate.__option === \"Some\") {\r\n+        startTime = group.guards.startDate.value.date;\r\n+      }\r\n+      if (group.guards.endDate.__option === \"Some\") {\r\n+        endTime = group.guards.endDate.value.date;\r\n+      }\r\n+    }\r\n+\r\n+    let buttonElement: GuardButtonList = {\r\n+      label: guard ? guard.label : \"default\",\r\n+      allowed: guard.allowed,\r\n+      // header: text ? text.header : \"header missing in settings.tsx\",\r\n+      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n+      header: text ? text.header : \"\",\r\n+      mintText: text ? text.mintText : \"\",\r\n+      // buttonLabel: text\r\n+      //   ? text.buttonLabel\r\n+      //   : \"buttonLabel missing in settings.tsx\",\r\n+      buttonLabel: text\r\n+        ? text.buttonLabel\r\n+        : \"\",\r\n+      startTime,\r\n+      endTime,\r\n+      tooltip: guard.reason,\r\n+      maxAmount: guard.maxAmount,\r\n+    };\r\n+    buttonGuardList.push(buttonElement);\r\n+    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n+  }\r\n+\r\n+  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n+    <Box key={index} >\r\n+      {/* <Divider my=\"10px\" /> */}\r\n+      <HStack>\r\n+        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n+          {buttonGuard.header}\r\n+        </Heading>\r\n+        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n+          {buttonGuard.endTime > createBigInt(0) &&\r\n+            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.startTime ||\r\n+              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Ending in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.endTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )}\r\n+          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n+            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n+            (!buttonGuard.endTime ||\r\n+              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n+              <>\r\n+                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n+                  Starting in:{\" \"}\r\n+                </Text>\r\n+                <Timer\r\n+                  toTime={buttonGuard.startTime}\r\n+                  solanaTime={solanaTime}\r\n+                  setCheckEligibility={setCheckEligibility}\r\n+                />\r\n+              </>\r\n+            )} */}\r\n+        </Flex>\r\n+      </HStack>\r\n+      <SimpleGrid columns={2} spacing={5}>\r\n+        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n+          {buttonGuard.mintText}\r\n+        </Text> */}\r\n+        <VStack>\r\n+          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n+            <NumberInput\r\n+              value={numberInputValues[buttonGuard.label] || 1}\r\n+              min={1}\r\n+              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n+              size=\"sm\"\r\n+              // isDisabled={!buttonGuard.allowed}\r\n+              onChange={(valueAsString, valueAsNumber) =>\r\n+                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n+              }\r\n+            >\r\n+              <NumberInputField />\r\n+              <NumberInputStepper>\r\n+                <NumberIncrementStepper />\r\n+                <NumberDecrementStepper />\r\n+              </NumberInputStepper>\r\n+            </NumberInput>\r\n+          ) : null}\r\n+\r\n+          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n+          <Button\r\n+            onClick={() =>\r\n+              mintClick(\r\n+                umi,\r\n+                buttonGuard,\r\n+                candyMachine,\r\n+                candyGuard,\r\n+                ownedTokens,\r\n+                numberInputValues[buttonGuard.label] || 1,\r\n+                mintsCreated,\r\n+                setMintsCreated,\r\n+                guardList,\r\n+                setGuardList,\r\n+                onOpen,\r\n+                setCheckEligibility\r\n+              )\r\n+            }\r\n+            key={buttonGuard.label}\r\n+            // size=\"sm\"\r\n+            backgroundColor=\"teal.100\"\r\n+            // isDisabled={!buttonGuard.allowed}\r\n+            className={'mint-button'}\r\n+            isLoading={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.minting\r\n+            }\r\n+            loadingText={\r\n+              guardList.find((elem) => elem.label === buttonGuard.label)\r\n+                ?.loadingText\r\n+            }\r\n+          >\r\n+            <FormattedMessage id={'mint'} />\r\n+            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n+            {/* {buttonGuard.buttonLabel} */}\r\n+          </Button>\r\n+          {/* </Tooltip> */}\r\n+        </VStack>\r\n+      </SimpleGrid>\r\n+    </Box>\r\n+  ));\r\n+\r\n+  return <>{listItems}</>;\r\n+}\r\n+\r\n+const mintButton2 = () => {\r\n+  return (\r\n+    <div>\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default mintButton2;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731607720878,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -62,9 +62,8 @@\n import { verifyTx } from \".././utils/verifyTx\";\r\n import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n import { FormattedMessage } from 'react-intl';\r\n import { messages } from '.././locales';\r\n-import { useWallet } from \"@solana/wallet-adapter-react\";\r\n \r\n const updateLoadingText = (\r\n   loadingText: string | undefined,\r\n   guardList: GuardReturn[],\r\n@@ -669,4089 +668,5 @@\n     </div>\r\n   );\r\n };\r\n \r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-import { useWallet } from \"@solana/wallet-adapter-react\";\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-export function handleButtonClickFunt({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [],\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const { connected, connect } = useWallet(); // 获取连接状态和连接函数\r\n-\r\n-  const handleButtonClick = async () => {\r\n-    if (!connected) {\r\n-      // 如果钱包未连接，调用连接函数\r\n-      await connect();\r\n-    } else {\r\n-      // 如果钱包已连接，执行铸造逻辑\r\n-      mintClick(\r\n-        umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-      );\r\n-    }\r\n-  };\r\n-\r\n-  return (\r\n-    <Button\r\n-      onClick={handleButtonClick}\r\n-      className={'mint-button'}\r\n-      isLoading={guardList.find((elem) => elem.label === guard.label)?.minting}\r\n-      loadingText={guardList.find((elem) => elem.label === guard.label)?.loadingText}\r\n-      backgroundColor=\"teal.100\"\r\n-    >\r\n-      <FormattedMessage id={'mint'} />\r\n-    </Button>\r\n-  );\r\n-}\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      ``,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      {/* <Divider my=\"10px\" /> */}\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text> */}\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-            onClick={() =>\r\n-              mintClick(\r\n-                umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-              )\r\n-            }\r\n-            key={buttonGuard.label}\r\n-            // size=\"sm\"\r\n-            backgroundColor=\"teal.100\"\r\n-            // isDisabled={!buttonGuard.allowed}\r\n-            className={'mint-button'}\r\n-            isLoading={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.minting\r\n-            }\r\n-            loadingText={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.loadingText\r\n-            }\r\n-          >\r\n-            <FormattedMessage id={'mint'} />\r\n-            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-            {/* {buttonGuard.buttonLabel} */}\r\n-          </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-import { useWallet } from \"@solana/wallet-adapter-react\";\r\n-\r\n-const { connected, connect } = useWallet(); // 获取连接状态和连接函数\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      ``,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      {/* <Divider my=\"10px\" /> */}\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text> */}\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-            onClick={() =>\r\n-              mintClick(\r\n-                umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-              )\r\n-            }\r\n-            key={buttonGuard.label}\r\n-            // size=\"sm\"\r\n-            backgroundColor=\"teal.100\"\r\n-            // isDisabled={!buttonGuard.allowed}\r\n-            className={'mint-button'}\r\n-            isLoading={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.minting\r\n-            }\r\n-            loadingText={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.loadingText\r\n-            }\r\n-          >\r\n-            <FormattedMessage id={'mint'} />\r\n-            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-            {/* {buttonGuard.buttonLabel} */}\r\n-          </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      ``,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      {/* <Divider my=\"10px\" /> */}\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text> */}\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-            onClick={() =>\r\n-              mintClick(\r\n-                umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-              )\r\n-            }\r\n-            key={buttonGuard.label}\r\n-            // size=\"sm\"\r\n-            backgroundColor=\"teal.100\"\r\n-            // isDisabled={!buttonGuard.allowed}\r\n-            className={'mint-button'}\r\n-            isLoading={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.minting\r\n-            }\r\n-            loadingText={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.loadingText\r\n-            }\r\n-          >\r\n-            <FormattedMessage id={'mint'} />\r\n-            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-            {/* {buttonGuard.buttonLabel} */}\r\n-          </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      ``,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      {/* <Divider my=\"10px\" /> */}\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text> */}\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-            onClick={() =>\r\n-              mintClick(\r\n-                umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-              )\r\n-            }\r\n-            key={buttonGuard.label}\r\n-            // size=\"sm\"\r\n-            // isDisabled={!buttonGuard.allowed}\r\n-            className={'mint-button'}\r\n-            isLoading={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.minting\r\n-            }\r\n-            loadingText={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.loadingText\r\n-            }\r\n-          >\r\n-            <FormattedMessage id={'mint'} />\r\n-            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-            {/* {buttonGuard.buttonLabel} */}\r\n-          </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      ``,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      {/* <Divider my=\"10px\" /> */}\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text> */}\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-            onClick={() =>\r\n-              mintClick(\r\n-                umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-              )\r\n-            }\r\n-            key={buttonGuard.label}\r\n-            // size=\"sm\"\r\n-            backgroundColor=\"teal.100\"\r\n-            // isDisabled={!buttonGuard.allowed}\r\n-            className={'mint-button'}\r\n-            isLoading={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.minting\r\n-            }\r\n-            loadingText={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.loadingText\r\n-            }\r\n-          >\r\n-            <FormattedMessage id={'mint'} />\r\n-            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-            {/* {buttonGuard.buttonLabel} */}\r\n-          </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default mintButton2;\n-import {\r\n-  CandyGuard,\r\n-  CandyMachine,\r\n-  mintV2,\r\n-} from \"@metaplex-foundation/mpl-candy-machine\";\r\n-import { GuardReturn } from \".././utils/checkerHelper\";\r\n-import {\r\n-  AddressLookupTableInput,\r\n-  KeypairSigner,\r\n-  PublicKey,\r\n-  Transaction,\r\n-  Umi,\r\n-  createBigInt,\r\n-  generateSigner,\r\n-  none,\r\n-  publicKey,\r\n-  signAllTransactions,\r\n-  signTransaction,\r\n-  sol,\r\n-  some,\r\n-  transactionBuilder,\r\n-} from \"@metaplex-foundation/umi\";\r\n-import {\r\n-  DigitalAsset,\r\n-  DigitalAssetWithToken,\r\n-  JsonMetadata,\r\n-  fetchDigitalAsset,\r\n-  fetchJsonMetadata,\r\n-} from \"@metaplex-foundation/mpl-token-metadata\";\r\n-import { mintText } from \".././settings\";\r\n-import {\r\n-  Box,\r\n-  Button,\r\n-  Flex,\r\n-  HStack,\r\n-  Heading,\r\n-  SimpleGrid,\r\n-  Text,\r\n-  Tooltip,\r\n-  NumberInput,\r\n-  NumberInputField,\r\n-  NumberInputStepper,\r\n-  NumberIncrementStepper,\r\n-  NumberDecrementStepper,\r\n-  VStack,\r\n-  Divider,\r\n-  createStandaloneToast,\r\n-} from \"@chakra-ui/react\";\r\n-import {\r\n-  fetchAddressLookupTable, setComputeUnitPrice,\r\n-} from \"@metaplex-foundation/mpl-toolbox\";\r\n-import { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\n-import {\r\n-  chooseGuardToUse,\r\n-  routeBuilder,\r\n-  mintArgsBuilder,\r\n-  GuardButtonList,\r\n-  buildTx,\r\n-  getRequiredCU,\r\n-} from \"../utils/mintHelper\";\r\n-import { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\n-import { verifyTx } from \".././utils/verifyTx\";\r\n-import { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n-import { FormattedMessage } from 'react-intl';\r\n-import { messages } from '.././locales';\r\n-\r\n-const updateLoadingText = (\r\n-  loadingText: string | undefined,\r\n-  guardList: GuardReturn[],\r\n-  label: string,\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n-) => {\r\n-  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n-  if (guardIndex === -1) {\r\n-    console.error(\"guard not found\");\r\n-    return;\r\n-  }\r\n-  const newGuardList = [...guardList];\r\n-  newGuardList[guardIndex].loadingText = loadingText;\r\n-  setGuardList(newGuardList);\r\n-};\r\n-\r\n-const fetchNft = async (\r\n-  umi: Umi,\r\n-  nftAdress: PublicKey,\r\n-) => {\r\n-  let digitalAsset: DigitalAsset | undefined;\r\n-  let jsonMetadata: JsonMetadata | undefined;\r\n-  try {\r\n-    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n-    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n-  } catch (e) {\r\n-    console.error(e);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Nft could not be fetched!\",\r\n-      description: \"Please check your Wallet instead.\",\r\n-      status: \"info\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  }\r\n-\r\n-  return { digitalAsset, jsonMetadata };\r\n-};\r\n-\r\n-const mintClick = async (\r\n-  umi: Umi,\r\n-  guard: GuardReturn,\r\n-  candyMachine: CandyMachine,\r\n-  candyGuard: CandyGuard,\r\n-  ownedTokens: DigitalAssetWithToken[],\r\n-  mintAmount: number,\r\n-  mintsCreated:\r\n-    | {\r\n-      mint: PublicKey;\r\n-      offChainMetadata: JsonMetadata | undefined;\r\n-    }[]\r\n-    | undefined,\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >,\r\n-  guardList: GuardReturn[],\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n-  onOpen: () => void,\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n-) => {\r\n-  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n-  if (!guardToUse.guards) {\r\n-    console.error(\"no guard defined!\");\r\n-    return;\r\n-  }\r\n-\r\n-  let buyBeer = false;\r\n-  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n-\r\n-  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n-    buyBeer = false;\r\n-    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n-  }\r\n-\r\n-  try {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = true;\r\n-    setGuardList(newGuardList);\r\n-\r\n-    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n-    if (routeBuild && routeBuild.items.length > 0) {\r\n-      createStandaloneToast().toast({\r\n-        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n-        status: \"info\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n-      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n-      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n-      const builtTx = await routeBuild.buildAndSign(umi);\r\n-      const sig = await umi.rpc\r\n-        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          createStandaloneToast().toast({\r\n-            title: \"Allow List TX failed!\",\r\n-            status: \"error\",\r\n-            duration: 900,\r\n-            isClosable: true,\r\n-          });\r\n-          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n-\r\n-        });\r\n-      if (sig.status === \"fulfilled\")\r\n-        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n-\r\n-    }\r\n-\r\n-    // fetch LUT\r\n-    let tables: AddressLookupTableInput[] = [];\r\n-    const lut = process.env.NEXT_PUBLIC_LUT;\r\n-    if (lut) {\r\n-      const lutPubKey = publicKey(lut);\r\n-      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n-      tables = [fetchedLut];\r\n-    } else {\r\n-      createStandaloneToast().toast({\r\n-        title: \"The developer should really set a lookup table!\",\r\n-        status: \"warning\",\r\n-        duration: 900,\r\n-        isClosable: true,\r\n-      });\r\n-    }\r\n-\r\n-    const mintTxs: Transaction[] = [];\r\n-    let nftsigners = [] as KeypairSigner[];\r\n-\r\n-    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n-\r\n-    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n-    const nftMint = generateSigner(umi);\r\n-    const txForSimulation = buildTx(\r\n-      umi,\r\n-      candyMachine,\r\n-      candyGuard,\r\n-      nftMint,\r\n-      guardToUse,\r\n-      mintArgs,\r\n-      tables,\r\n-      latestBlockhash,\r\n-      1_400_000,\r\n-      buyBeer\r\n-    );\r\n-    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n-\r\n-    for (let i = 0; i < mintAmount; i++) {\r\n-      const nftMint = generateSigner(umi);\r\n-      nftsigners.push(nftMint);\r\n-      const transaction = buildTx(\r\n-        umi,\r\n-        candyMachine,\r\n-        candyGuard,\r\n-        nftMint,\r\n-        guardToUse,\r\n-        mintArgs,\r\n-        tables,\r\n-        latestBlockhash,\r\n-        requiredCu,\r\n-        buyBeer\r\n-      );\r\n-      console.log(transaction)\r\n-      mintTxs.push(transaction);\r\n-    }\r\n-    if (!mintTxs.length) {\r\n-      console.error(\"no mint tx built!\");\r\n-      return;\r\n-    }\r\n-    // 获取当前语言的 \"sign\" 文本\r\n-    const signText = messages['en'].sign;\r\n-\r\n-    updateLoadingText(\r\n-      signText,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-    const signedTransactions = await signAllTransactions(\r\n-      mintTxs.map((transaction, index) => ({\r\n-        transaction,\r\n-        signers: [umi.payer, nftsigners[index]],\r\n-      }))\r\n-    );\r\n-\r\n-    let signatures: Uint8Array[] = [];\r\n-    let amountSent = 0;\r\n-\r\n-    const sendPromises = signedTransactions.map((tx, index) => {\r\n-      return umi.rpc\r\n-        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n-        .then((signature) => {\r\n-          console.log(\r\n-            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n-            }`\r\n-          );\r\n-          amountSent = amountSent + 1;\r\n-          signatures.push(signature);\r\n-          return { status: \"fulfilled\", value: signature };\r\n-        })\r\n-        .catch((error) => {\r\n-          console.error(`Transaction ${index + 1} failed:`, error);\r\n-          return { status: \"rejected\", reason: error };\r\n-        });\r\n-    });\r\n-\r\n-    await Promise.allSettled(sendPromises);\r\n-\r\n-    if (!(await sendPromises[0]).status === true) {\r\n-      // throw error that no tx was created\r\n-      throw new Error(\"no tx was created\");\r\n-    }\r\n-    updateLoadingText(\r\n-      ``,\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    createStandaloneToast().toast({\r\n-      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n-      status: \"success\",\r\n-      duration: 3000,\r\n-    });\r\n-\r\n-    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n-\r\n-    updateLoadingText(\r\n-      \"Fetching your NFT\",\r\n-      guardList,\r\n-      guardToUse.label,\r\n-      setGuardList\r\n-    );\r\n-\r\n-    // Filter out successful mints and map to fetch promises\r\n-    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n-      fetchNft(umi, mintResult).then((nftData) => ({\r\n-        mint: mintResult,\r\n-        nftData,\r\n-      }))\r\n-    );\r\n-\r\n-    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n-\r\n-    // Prepare data for setting mintsCreated\r\n-    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n-      [];\r\n-    fetchedNftsResults.map((acc) => {\r\n-      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n-        newMintsCreated.push({\r\n-          mint: acc.mint,\r\n-          offChainMetadata: acc.nftData.jsonMetadata,\r\n-        });\r\n-      }\r\n-      return acc;\r\n-    }, []);\r\n-\r\n-    // Update mintsCreated only if there are new mints\r\n-    if (newMintsCreated.length > 0) {\r\n-      setMintsCreated(newMintsCreated);\r\n-      onOpen();\r\n-    }\r\n-  } catch (e) {\r\n-    console.error(`minting failed because of ${e}`);\r\n-    createStandaloneToast().toast({\r\n-      title: \"Your mint failed!\",\r\n-      description: \"Please try again.\",\r\n-      status: \"error\",\r\n-      duration: 900,\r\n-      isClosable: true,\r\n-    });\r\n-  } finally {\r\n-    //find the guard by guardToUse.label and set minting to true\r\n-    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n-    if (guardIndex === -1) {\r\n-      console.error(\"guard not found\");\r\n-      return;\r\n-    }\r\n-    const newGuardList = [...guardList];\r\n-    newGuardList[guardIndex].minting = false;\r\n-    setGuardList(newGuardList);\r\n-    setCheckEligibility(true);\r\n-    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n-  }\r\n-};\r\n-// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\n-const Timer = ({\r\n-  solanaTime,\r\n-  toTime,\r\n-  setCheckEligibility,\r\n-}: {\r\n-  solanaTime: bigint;\r\n-  toTime: bigint;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-}) => {\r\n-  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n-    toTime - solanaTime\r\n-  );\r\n-  useEffect(() => {\r\n-    const interval = setInterval(() => {\r\n-      setRemainingTime((prev) => {\r\n-        return prev - BigInt(1);\r\n-      });\r\n-    }, 1000);\r\n-    return () => clearInterval(interval);\r\n-  }, []);\r\n-\r\n-  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n-  const days = remainingTime / BigInt(86400);\r\n-  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n-  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n-  const seconds = remainingTime % BigInt(60);\r\n-  if (days > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {days.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        d{\" \"}\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (hours > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {hours.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        h{\" \"}\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n-    return (\r\n-      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n-        {minutes.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        m{\" \"}\r\n-        {seconds.toLocaleString(\"en-US\", {\r\n-          minimumIntegerDigits: 2,\r\n-          useGrouping: false,\r\n-        })}\r\n-        s\r\n-      </Text>\r\n-    );\r\n-  }\r\n-  if (remainingTime === BigInt(0)) {\r\n-    setCheckEligibility(true);\r\n-  }\r\n-  return <Text></Text>;\r\n-};\r\n-\r\n-type Props = {\r\n-  umi: Umi;\r\n-  guardList: GuardReturn[];\r\n-  candyMachine: CandyMachine | undefined;\r\n-  candyGuard: CandyGuard | undefined;\r\n-  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n-  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n-  mintsCreated:\r\n-  | {\r\n-    mint: PublicKey;\r\n-    offChainMetadata: JsonMetadata | undefined;\r\n-  }[]\r\n-  | undefined;\r\n-  setMintsCreated: Dispatch<\r\n-    SetStateAction<\r\n-      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n-      | undefined\r\n-    >\r\n-  >;\r\n-  onOpen: () => void;\r\n-  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n-};\r\n-\r\n-export function ButtonList({\r\n-  umi,\r\n-  guardList,\r\n-  candyMachine,\r\n-  candyGuard,\r\n-  ownedTokens = [], // provide default empty array\r\n-  setGuardList,\r\n-  mintsCreated,\r\n-  setMintsCreated,\r\n-  onOpen,\r\n-  setCheckEligibility,\r\n-}: Props): JSX.Element {\r\n-  const solanaTime = useSolanaTime();\r\n-  const [numberInputValues, setNumberInputValues] = useState<{\r\n-    [label: string]: number;\r\n-  }>({});\r\n-  if (!candyMachine || !candyGuard) {\r\n-    return <></>;\r\n-  }\r\n-\r\n-  const handleNumberInputChange = (label: string, value: number) => {\r\n-    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n-  };\r\n-\r\n-  // remove duplicates from guardList\r\n-  //fucked up bugfix\r\n-  let filteredGuardlist = guardList.filter(\r\n-    (elem, index, self) =>\r\n-      index === self.findIndex((t) => t.label === elem.label)\r\n-  );\r\n-  if (filteredGuardlist.length === 0) {\r\n-    return <></>;\r\n-  }\r\n-  // Guard \"default\" can only be used to mint in case no other guard exists\r\n-  if (filteredGuardlist.length > 1) {\r\n-    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n-  }\r\n-  let buttonGuardList = [];\r\n-  for (const guard of filteredGuardlist) {\r\n-    const text = mintText.find((elem) => elem.label === guard.label);\r\n-    // find guard by label in candyGuard\r\n-    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n-    let startTime = createBigInt(0);\r\n-    let endTime = createBigInt(0);\r\n-    if (group) {\r\n-      if (group.guards.startDate.__option === \"Some\") {\r\n-        startTime = group.guards.startDate.value.date;\r\n-      }\r\n-      if (group.guards.endDate.__option === \"Some\") {\r\n-        endTime = group.guards.endDate.value.date;\r\n-      }\r\n-    }\r\n-\r\n-    let buttonElement: GuardButtonList = {\r\n-      label: guard ? guard.label : \"default\",\r\n-      allowed: guard.allowed,\r\n-      // header: text ? text.header : \"header missing in settings.tsx\",\r\n-      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n-      header: text ? text.header : \"\",\r\n-      mintText: text ? text.mintText : \"\",\r\n-      // buttonLabel: text\r\n-      //   ? text.buttonLabel\r\n-      //   : \"buttonLabel missing in settings.tsx\",\r\n-      buttonLabel: text\r\n-        ? text.buttonLabel\r\n-        : \"\",\r\n-      startTime,\r\n-      endTime,\r\n-      tooltip: guard.reason,\r\n-      maxAmount: guard.maxAmount,\r\n-    };\r\n-    buttonGuardList.push(buttonElement);\r\n-    // console.log(\"buttonGuardList:\", buttonGuardList); \r\n-  }\r\n-\r\n-  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n-    <Box key={index} >\r\n-      {/* <Divider my=\"10px\" /> */}\r\n-      <HStack>\r\n-        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n-          {buttonGuard.header}\r\n-        </Heading>\r\n-        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n-          {buttonGuard.endTime > createBigInt(0) &&\r\n-            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.startTime ||\r\n-              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Ending in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.endTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )}\r\n-          {/* {buttonGuard.startTime > createBigInt(0) &&\r\n-            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n-            (!buttonGuard.endTime ||\r\n-              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n-              <>\r\n-                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n-                  Starting in:{\" \"}\r\n-                </Text>\r\n-                <Timer\r\n-                  toTime={buttonGuard.startTime}\r\n-                  solanaTime={solanaTime}\r\n-                  setCheckEligibility={setCheckEligibility}\r\n-                />\r\n-              </>\r\n-            )} */}\r\n-        </Flex>\r\n-      </HStack>\r\n-      <SimpleGrid columns={2} spacing={5}>\r\n-        {/* <Text pt=\"2\" fontSize=\"sm\">\r\n-          {buttonGuard.mintText}\r\n-        </Text> */}\r\n-        <VStack>\r\n-          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n-            <NumberInput\r\n-              value={numberInputValues[buttonGuard.label] || 1}\r\n-              min={1}\r\n-              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n-              size=\"sm\"\r\n-              // isDisabled={!buttonGuard.allowed}\r\n-              onChange={(valueAsString, valueAsNumber) =>\r\n-                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n-              }\r\n-            >\r\n-              <NumberInputField />\r\n-              <NumberInputStepper>\r\n-                <NumberIncrementStepper />\r\n-                <NumberDecrementStepper />\r\n-              </NumberInputStepper>\r\n-            </NumberInput>\r\n-          ) : null}\r\n-\r\n-          {/* <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\"> */}\r\n-          <Button\r\n-            onClick={() =>\r\n-              mintClick(\r\n-                umi,\r\n-                buttonGuard,\r\n-                candyMachine,\r\n-                candyGuard,\r\n-                ownedTokens,\r\n-                numberInputValues[buttonGuard.label] || 1,\r\n-                mintsCreated,\r\n-                setMintsCreated,\r\n-                guardList,\r\n-                setGuardList,\r\n-                onOpen,\r\n-                setCheckEligibility\r\n-              )\r\n-            }\r\n-            key={buttonGuard.label}\r\n-            // size=\"sm\"\r\n-            backgroundColor=\"teal.100\"\r\n-            // isDisabled={!buttonGuard.allowed}\r\n-            isLoading={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.minting\r\n-            }\r\n-            loadingText={\r\n-              guardList.find((elem) => elem.label === buttonGuard.label)\r\n-                ?.loadingText\r\n-            }\r\n-          >\r\n-            <FormattedMessage id={'mint'} />\r\n-            {/* <FormattedMessage id={!buttonGuard.allowed ? 'notMint' : buttonGuard.allowed ? 'mint' : 'minted'} /> */}\r\n-            {/* {buttonGuard.buttonLabel} */}\r\n-          </Button>\r\n-          {/* </Tooltip> */}\r\n-        </VStack>\r\n-      </SimpleGrid>\r\n-    </Box>\r\n-  ));\r\n-\r\n-  return <>{listItems}</>;\r\n-}\r\n-\r\n-const mintButton2 = () => {\r\n-  return (\r\n-    <div>\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n export default mintButton2;\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731332300638,
            "name": "Commit-0",
            "content": "import {\r\n  CandyGuard,\r\n  CandyMachine,\r\n  mintV2,\r\n} from \"@metaplex-foundation/mpl-candy-machine\";\r\nimport { GuardReturn } from \".././utils/checkerHelper\";\r\nimport {\r\n  AddressLookupTableInput,\r\n  KeypairSigner,\r\n  PublicKey,\r\n  Transaction,\r\n  Umi,\r\n  createBigInt,\r\n  generateSigner,\r\n  none,\r\n  publicKey,\r\n  signAllTransactions,\r\n  signTransaction,\r\n  sol,\r\n  some,\r\n  transactionBuilder,\r\n} from \"@metaplex-foundation/umi\";\r\nimport {\r\n  DigitalAsset,\r\n  DigitalAssetWithToken,\r\n  JsonMetadata,\r\n  fetchDigitalAsset,\r\n  fetchJsonMetadata,\r\n} from \"@metaplex-foundation/mpl-token-metadata\";\r\nimport { mintText } from \".././settings\";\r\nimport {\r\n  Box,\r\n  Button,\r\n  Flex,\r\n  HStack,\r\n  Heading,\r\n  SimpleGrid,\r\n  Text,\r\n  Tooltip,\r\n  NumberInput,\r\n  NumberInputField,\r\n  NumberInputStepper,\r\n  NumberIncrementStepper,\r\n  NumberDecrementStepper,\r\n  VStack,\r\n  Divider,\r\n  createStandaloneToast,\r\n} from \"@chakra-ui/react\";\r\nimport {\r\n  fetchAddressLookupTable, setComputeUnitPrice,\r\n} from \"@metaplex-foundation/mpl-toolbox\";\r\nimport { Dispatch, SetStateAction, useEffect, useState } from \"react\";\r\nimport {\r\n  chooseGuardToUse,\r\n  routeBuilder,\r\n  mintArgsBuilder,\r\n  GuardButtonList,\r\n  buildTx,\r\n  getRequiredCU,\r\n} from \"../utils/mintHelper\";\r\nimport { useSolanaTime } from \".././utils/SolanaTimeContext\";\r\nimport { verifyTx } from \".././utils/verifyTx\";\r\nimport { base58 } from \"@metaplex-foundation/umi/serializers\";\r\n\r\nconst updateLoadingText = (\r\n  loadingText: string | undefined,\r\n  guardList: GuardReturn[],\r\n  label: string,\r\n  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>\r\n) => {\r\n  const guardIndex = guardList.findIndex((g) => g.label === label);\r\n  if (guardIndex === -1) {\r\n    console.error(\"guard not found\");\r\n    return;\r\n  }\r\n  const newGuardList = [...guardList];\r\n  newGuardList[guardIndex].loadingText = loadingText;\r\n  setGuardList(newGuardList);\r\n};\r\n\r\nconst fetchNft = async (\r\n  umi: Umi,\r\n  nftAdress: PublicKey,\r\n) => {\r\n  let digitalAsset: DigitalAsset | undefined;\r\n  let jsonMetadata: JsonMetadata | undefined;\r\n  try {\r\n    digitalAsset = await fetchDigitalAsset(umi, nftAdress);\r\n    jsonMetadata = await fetchJsonMetadata(umi, digitalAsset.metadata.uri);\r\n  } catch (e) {\r\n    console.error(e);\r\n    createStandaloneToast().toast({\r\n      title: \"Nft could not be fetched!\",\r\n      description: \"Please check your Wallet instead.\",\r\n      status: \"info\",\r\n      duration: 900,\r\n      isClosable: true,\r\n    });\r\n  }\r\n\r\n  return { digitalAsset, jsonMetadata };\r\n};\r\n\r\nconst mintClick = async (\r\n  umi: Umi,\r\n  guard: GuardReturn,\r\n  candyMachine: CandyMachine,\r\n  candyGuard: CandyGuard,\r\n  ownedTokens: DigitalAssetWithToken[],\r\n  mintAmount: number,\r\n  mintsCreated:\r\n    | {\r\n      mint: PublicKey;\r\n      offChainMetadata: JsonMetadata | undefined;\r\n    }[]\r\n    | undefined,\r\n  setMintsCreated: Dispatch<\r\n    SetStateAction<\r\n      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n      | undefined\r\n    >\r\n  >,\r\n  guardList: GuardReturn[],\r\n  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>,\r\n  onOpen: () => void,\r\n  setCheckEligibility: Dispatch<SetStateAction<boolean>>\r\n) => {\r\n  const guardToUse = chooseGuardToUse(guard, candyGuard);\r\n  if (!guardToUse.guards) {\r\n    console.error(\"no guard defined!\");\r\n    return;\r\n  }\r\n\r\n  let buyBeer = false;\r\n  console.log(\"buyBeer\", process.env.NEXT_PUBLIC_BUYMARKBEER)\r\n\r\n  if (process.env.NEXT_PUBLIC_BUYMARKBEER === \"false\") {\r\n    buyBeer = false;\r\n    console.log(\"The Creator does not want to pay for MarkSackerbergs beer 😒\");\r\n  }\r\n\r\n  try {\r\n    //find the guard by guardToUse.label and set minting to true\r\n    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n    if (guardIndex === -1) {\r\n      console.error(\"guard not found\");\r\n      return;\r\n    }\r\n    const newGuardList = [...guardList];\r\n    newGuardList[guardIndex].minting = true;\r\n    setGuardList(newGuardList);\r\n\r\n    let routeBuild = await routeBuilder(umi, guardToUse, candyMachine);\r\n    if (routeBuild && routeBuild.items.length > 0) {\r\n      createStandaloneToast().toast({\r\n        title: \"Allowlist detected. Please sign to be approved to mint.\",\r\n        status: \"info\",\r\n        duration: 900,\r\n        isClosable: true,\r\n      });\r\n      routeBuild = routeBuild.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\r\n      const latestBlockhash = await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" });\r\n      routeBuild = routeBuild.setBlockhash(latestBlockhash)\r\n      const builtTx = await routeBuild.buildAndSign(umi);\r\n      const sig = await umi.rpc\r\n        .sendTransaction(builtTx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n        .then((signature) => {\r\n          return { status: \"fulfilled\", value: signature };\r\n        })\r\n        .catch((error) => {\r\n          createStandaloneToast().toast({\r\n            title: \"Allow List TX failed!\",\r\n            status: \"error\",\r\n            duration: 900,\r\n            isClosable: true,\r\n          });\r\n          return { status: \"rejected\", reason: error, value: new Uint8Array };\r\n\r\n        });\r\n      if (sig.status === \"fulfilled\")\r\n        await verifyTx(umi, [sig.value], latestBlockhash, \"finalized\");\r\n\r\n    }\r\n\r\n    // fetch LUT\r\n    let tables: AddressLookupTableInput[] = [];\r\n    const lut = process.env.NEXT_PUBLIC_LUT;\r\n    if (lut) {\r\n      const lutPubKey = publicKey(lut);\r\n      const fetchedLut = await fetchAddressLookupTable(umi, lutPubKey);\r\n      tables = [fetchedLut];\r\n    } else {\r\n      createStandaloneToast().toast({\r\n        title: \"The developer should really set a lookup table!\",\r\n        status: \"warning\",\r\n        duration: 900,\r\n        isClosable: true,\r\n      });\r\n    }\r\n\r\n    const mintTxs: Transaction[] = [];\r\n    let nftsigners = [] as KeypairSigner[];\r\n\r\n    const latestBlockhash = (await umi.rpc.getLatestBlockhash({ commitment: \"finalized\" }));\r\n\r\n    const mintArgs = mintArgsBuilder(candyMachine, guardToUse, ownedTokens);\r\n    const nftMint = generateSigner(umi);\r\n    const txForSimulation = buildTx(\r\n      umi,\r\n      candyMachine,\r\n      candyGuard,\r\n      nftMint,\r\n      guardToUse,\r\n      mintArgs,\r\n      tables,\r\n      latestBlockhash,\r\n      1_400_000,\r\n      buyBeer\r\n    );\r\n    const requiredCu = await getRequiredCU(umi, txForSimulation);\r\n\r\n    for (let i = 0; i < mintAmount; i++) {\r\n      const nftMint = generateSigner(umi);\r\n      nftsigners.push(nftMint);\r\n      const transaction = buildTx(\r\n        umi,\r\n        candyMachine,\r\n        candyGuard,\r\n        nftMint,\r\n        guardToUse,\r\n        mintArgs,\r\n        tables,\r\n        latestBlockhash,\r\n        requiredCu,\r\n        buyBeer\r\n      );\r\n      console.log(transaction)\r\n      mintTxs.push(transaction);\r\n    }\r\n    if (!mintTxs.length) {\r\n      console.error(\"no mint tx built!\");\r\n      return;\r\n    }\r\n\r\n    updateLoadingText(`Please sign`, guardList, guardToUse.label, setGuardList);\r\n    const signedTransactions = await signAllTransactions(\r\n      mintTxs.map((transaction, index) => ({\r\n        transaction,\r\n        signers: [umi.payer, nftsigners[index]],\r\n      }))\r\n    );\r\n\r\n    let signatures: Uint8Array[] = [];\r\n    let amountSent = 0;\r\n\r\n    const sendPromises = signedTransactions.map((tx, index) => {\r\n      return umi.rpc\r\n        .sendTransaction(tx, { skipPreflight: true, maxRetries: 1, preflightCommitment: \"finalized\", commitment: \"finalized\" })\r\n        .then((signature) => {\r\n          console.log(\r\n            `Transaction ${index + 1} resolved with signature: ${base58.deserialize(signature)[0]\r\n            }`\r\n          );\r\n          amountSent = amountSent + 1;\r\n          signatures.push(signature);\r\n          return { status: \"fulfilled\", value: signature };\r\n        })\r\n        .catch((error) => {\r\n          console.error(`Transaction ${index + 1} failed:`, error);\r\n          return { status: \"rejected\", reason: error };\r\n        });\r\n    });\r\n\r\n    await Promise.allSettled(sendPromises);\r\n\r\n    if (!(await sendPromises[0]).status === true) {\r\n      // throw error that no tx was created\r\n      throw new Error(\"no tx was created\");\r\n    }\r\n    updateLoadingText(\r\n      `finalizing transaction(s)`,\r\n      guardList,\r\n      guardToUse.label,\r\n      setGuardList\r\n    );\r\n\r\n    createStandaloneToast().toast({\r\n      title: `${signedTransactions.length} Transaction(s) sent!`,\r\n      status: \"success\",\r\n      duration: 3000,\r\n    });\r\n\r\n    const successfulMints = await verifyTx(umi, signatures, latestBlockhash, \"finalized\");\r\n\r\n    updateLoadingText(\r\n      \"Fetching your NFT\",\r\n      guardList,\r\n      guardToUse.label,\r\n      setGuardList\r\n    );\r\n\r\n    // Filter out successful mints and map to fetch promises\r\n    const fetchNftPromises = successfulMints.map((mintResult) =>\r\n      fetchNft(umi, mintResult).then((nftData) => ({\r\n        mint: mintResult,\r\n        nftData,\r\n      }))\r\n    );\r\n\r\n    const fetchedNftsResults = await Promise.all(fetchNftPromises);\r\n\r\n    // Prepare data for setting mintsCreated\r\n    let newMintsCreated: { mint: PublicKey; offChainMetadata: JsonMetadata }[] =\r\n      [];\r\n    fetchedNftsResults.map((acc) => {\r\n      if (acc.nftData.digitalAsset && acc.nftData.jsonMetadata) {\r\n        newMintsCreated.push({\r\n          mint: acc.mint,\r\n          offChainMetadata: acc.nftData.jsonMetadata,\r\n        });\r\n      }\r\n      return acc;\r\n    }, []);\r\n\r\n    // Update mintsCreated only if there are new mints\r\n    if (newMintsCreated.length > 0) {\r\n      setMintsCreated(newMintsCreated);\r\n      onOpen();\r\n    }\r\n  } catch (e) {\r\n    console.error(`minting failed because of ${e}`);\r\n    createStandaloneToast().toast({\r\n      title: \"Your mint failed!\",\r\n      description: \"Please try again.\",\r\n      status: \"error\",\r\n      duration: 900,\r\n      isClosable: true,\r\n    });\r\n  } finally {\r\n    //find the guard by guardToUse.label and set minting to true\r\n    const guardIndex = guardList.findIndex((g) => g.label === guardToUse.label);\r\n    if (guardIndex === -1) {\r\n      console.error(\"guard not found\");\r\n      return;\r\n    }\r\n    const newGuardList = [...guardList];\r\n    newGuardList[guardIndex].minting = false;\r\n    setGuardList(newGuardList);\r\n    setCheckEligibility(true);\r\n    updateLoadingText(undefined, guardList, guardToUse.label, setGuardList);\r\n  }\r\n};\r\n// new component called timer that calculates the remaining Time based on the bigint solana time and the bigint toTime difference.\r\nconst Timer = ({\r\n  solanaTime,\r\n  toTime,\r\n  setCheckEligibility,\r\n}: {\r\n  solanaTime: bigint;\r\n  toTime: bigint;\r\n  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n}) => {\r\n  const [remainingTime, setRemainingTime] = useState<bigint>(\r\n    toTime - solanaTime\r\n  );\r\n  useEffect(() => {\r\n    const interval = setInterval(() => {\r\n      setRemainingTime((prev) => {\r\n        return prev - BigInt(1);\r\n      });\r\n    }, 1000);\r\n    return () => clearInterval(interval);\r\n  }, []);\r\n\r\n  //convert the remaining time in seconds to the amount of days, hours, minutes and seconds left\r\n  const days = remainingTime / BigInt(86400);\r\n  const hours = (remainingTime % BigInt(86400)) / BigInt(3600);\r\n  const minutes = (remainingTime % BigInt(3600)) / BigInt(60);\r\n  const seconds = remainingTime % BigInt(60);\r\n  if (days > BigInt(0)) {\r\n    return (\r\n      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n        {days.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        d{\" \"}\r\n        {hours.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        h{\" \"}\r\n        {minutes.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        m{\" \"}\r\n        {seconds.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        s\r\n      </Text>\r\n    );\r\n  }\r\n  if (hours > BigInt(0)) {\r\n    return (\r\n      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n        {hours.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        h{\" \"}\r\n        {minutes.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        m{\" \"}\r\n        {seconds.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        s\r\n      </Text>\r\n    );\r\n  }\r\n  if (minutes > BigInt(0) || seconds > BigInt(0)) {\r\n    return (\r\n      <Text fontSize=\"sm\" fontWeight=\"bold\">\r\n        {minutes.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        m{\" \"}\r\n        {seconds.toLocaleString(\"en-US\", {\r\n          minimumIntegerDigits: 2,\r\n          useGrouping: false,\r\n        })}\r\n        s\r\n      </Text>\r\n    );\r\n  }\r\n  if (remainingTime === BigInt(0)) {\r\n    setCheckEligibility(true);\r\n  }\r\n  return <Text></Text>;\r\n};\r\n\r\ntype Props = {\r\n  umi: Umi;\r\n  guardList: GuardReturn[];\r\n  candyMachine: CandyMachine | undefined;\r\n  candyGuard: CandyGuard | undefined;\r\n  ownedTokens: DigitalAssetWithToken[] | undefined;\r\n  setGuardList: Dispatch<SetStateAction<GuardReturn[]>>;\r\n  mintsCreated:\r\n  | {\r\n    mint: PublicKey;\r\n    offChainMetadata: JsonMetadata | undefined;\r\n  }[]\r\n  | undefined;\r\n  setMintsCreated: Dispatch<\r\n    SetStateAction<\r\n      | { mint: PublicKey; offChainMetadata: JsonMetadata | undefined }[]\r\n      | undefined\r\n    >\r\n  >;\r\n  onOpen: () => void;\r\n  setCheckEligibility: Dispatch<SetStateAction<boolean>>;\r\n};\r\n\r\nexport function ButtonList({\r\n  umi,\r\n  guardList,\r\n  candyMachine,\r\n  candyGuard,\r\n  ownedTokens = [], // provide default empty array\r\n  setGuardList,\r\n  mintsCreated,\r\n  setMintsCreated,\r\n  onOpen,\r\n  setCheckEligibility,\r\n}: Props): JSX.Element {\r\n  const solanaTime = useSolanaTime();\r\n  const [numberInputValues, setNumberInputValues] = useState<{\r\n    [label: string]: number;\r\n  }>({});\r\n  if (!candyMachine || !candyGuard) {\r\n    return <></>;\r\n  }\r\n\r\n  const handleNumberInputChange = (label: string, value: number) => {\r\n    setNumberInputValues((prev) => ({ ...prev, [label]: value }));\r\n  };\r\n\r\n  // remove duplicates from guardList\r\n  //fucked up bugfix\r\n  let filteredGuardlist = guardList.filter(\r\n    (elem, index, self) =>\r\n      index === self.findIndex((t) => t.label === elem.label)\r\n  );\r\n  if (filteredGuardlist.length === 0) {\r\n    return <></>;\r\n  }\r\n  // Guard \"default\" can only be used to mint in case no other guard exists\r\n  if (filteredGuardlist.length > 1) {\r\n    filteredGuardlist = guardList.filter((elem) => elem.label != \"default\");\r\n  }\r\n  let buttonGuardList = [];\r\n  for (const guard of filteredGuardlist) {\r\n    const text = mintText.find((elem) => elem.label === guard.label);\r\n    // find guard by label in candyGuard\r\n    const group = candyGuard.groups.find((elem) => elem.label === guard.label);\r\n    let startTime = createBigInt(0);\r\n    let endTime = createBigInt(0);\r\n    if (group) {\r\n      if (group.guards.startDate.__option === \"Some\") {\r\n        startTime = group.guards.startDate.value.date;\r\n      }\r\n      if (group.guards.endDate.__option === \"Some\") {\r\n        endTime = group.guards.endDate.value.date;\r\n      }\r\n    }\r\n\r\n    let buttonElement: GuardButtonList = {\r\n      label: guard ? guard.label : \"default\",\r\n      allowed: guard.allowed,\r\n      // header: text ? text.header : \"header missing in settings.tsx\",\r\n      // mintText: text ? text.mintText : \"mintText missing in settings.tsx\",\r\n      header: text ? text.header : \"\",\r\n      mintText: text ? text.mintText : \"\",\r\n      // buttonLabel: text\r\n      //   ? text.buttonLabel\r\n      //   : \"buttonLabel missing in settings.tsx\",\r\n      buttonLabel: text\r\n        ? text.buttonLabel\r\n        : \"\",\r\n      startTime,\r\n      endTime,\r\n      tooltip: guard.reason,\r\n      maxAmount: guard.maxAmount,\r\n    };\r\n    buttonGuardList.push(buttonElement);\r\n    console.log(\"buttonGuardList:\", buttonGuardList); \r\n  }\r\n\r\n  const listItems = buttonGuardList.map((buttonGuard, index) => (\r\n    <Box key={index} marginTop={\"20px\"}>\r\n      <Divider my=\"10px\" />\r\n      <HStack>\r\n        <Heading size=\"xs\" textTransform=\"uppercase\">\r\n          {buttonGuard.header}\r\n        </Heading>\r\n        <Flex justifyContent=\"flex-end\" marginLeft=\"auto\">\r\n          {buttonGuard.endTime > createBigInt(0) &&\r\n            buttonGuard.endTime - solanaTime > createBigInt(0) &&\r\n            (!buttonGuard.startTime ||\r\n              buttonGuard.startTime - solanaTime <= createBigInt(0)) && (\r\n              <>\r\n                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n                  Ending in:{\" \"}\r\n                </Text>\r\n                <Timer\r\n                  toTime={buttonGuard.endTime}\r\n                  solanaTime={solanaTime}\r\n                  setCheckEligibility={setCheckEligibility}\r\n                />\r\n              </>\r\n            )}\r\n          {buttonGuard.startTime > createBigInt(0) &&\r\n            buttonGuard.startTime - solanaTime > createBigInt(0) &&\r\n            (!buttonGuard.endTime ||\r\n              solanaTime - buttonGuard.endTime <= createBigInt(0)) && (\r\n              <>\r\n                <Text fontSize=\"sm\" marginRight={\"2\"}>\r\n                  Starting in:{\" \"}\r\n                </Text>\r\n                <Timer\r\n                  toTime={buttonGuard.startTime}\r\n                  solanaTime={solanaTime}\r\n                  setCheckEligibility={setCheckEligibility}\r\n                />\r\n              </>\r\n            )}\r\n        </Flex>\r\n      </HStack>\r\n      <SimpleGrid columns={2} spacing={5}>\r\n        <Text pt=\"2\" fontSize=\"sm\">\r\n          {buttonGuard.mintText}\r\n        </Text>\r\n        <VStack>\r\n          {process.env.NEXT_PUBLIC_MULTIMINT && buttonGuard.allowed ? (\r\n            <NumberInput\r\n              value={numberInputValues[buttonGuard.label] || 1}\r\n              min={1}\r\n              max={buttonGuard.maxAmount < 1 ? 1 : buttonGuard.maxAmount}\r\n              size=\"sm\"\r\n              isDisabled={!buttonGuard.allowed}\r\n              onChange={(valueAsString, valueAsNumber) =>\r\n                handleNumberInputChange(buttonGuard.label, valueAsNumber)\r\n              }\r\n            >\r\n              <NumberInputField />\r\n              <NumberInputStepper>\r\n                <NumberIncrementStepper />\r\n                <NumberDecrementStepper />\r\n              </NumberInputStepper>\r\n            </NumberInput>\r\n          ) : null}\r\n\r\n          <Tooltip label={buttonGuard.tooltip} aria-label=\"Mint button\">\r\n            <Button\r\n              onClick={() =>\r\n                mintClick(\r\n                  umi,\r\n                  buttonGuard,\r\n                  candyMachine,\r\n                  candyGuard,\r\n                  ownedTokens,\r\n                  numberInputValues[buttonGuard.label] || 1,\r\n                  mintsCreated,\r\n                  setMintsCreated,\r\n                  guardList,\r\n                  setGuardList,\r\n                  onOpen,\r\n                  setCheckEligibility\r\n                )\r\n              }\r\n              key={buttonGuard.label}\r\n              size=\"sm\"\r\n              backgroundColor=\"teal.100\"\r\n              isDisabled={!buttonGuard.allowed}\r\n              isLoading={\r\n                guardList.find((elem) => elem.label === buttonGuard.label)\r\n                  ?.minting\r\n              }\r\n              loadingText={\r\n                guardList.find((elem) => elem.label === buttonGuard.label)\r\n                  ?.loadingText\r\n              }\r\n            >\r\n              {buttonGuard.buttonLabel}\r\n            </Button>\r\n          </Tooltip>\r\n        </VStack>\r\n      </SimpleGrid>\r\n    </Box>\r\n  ));\r\n\r\n  return <>{listItems}</>;\r\n}\r\n\r\nconst mintButton2 = () => {\r\n  return (\r\n    <div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default mintButton2;"
        }
    ]
}