{
    "sourceFile": "pages/utils/mintHelper.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1731240696631,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731240787689,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,397 @@\n+import { allowLists } from \".././allowlist\";\n+import {\n+  CandyGuard,\n+  CandyMachine,\n+  GuardGroup,\n+  DefaultGuardSet,\n+  DefaultGuardSetMintArgs,\n+  getMerkleRoot,\n+  route,\n+  getMerkleProof,\n+  safeFetchAllowListProofFromSeeds,\n+  mintV2,\n+} from \"@metaplex-foundation/mpl-candy-machine\";\n+import {\n+  DigitalAssetWithToken,\n+  TokenStandard,\n+} from \"@metaplex-foundation/mpl-token-metadata\";\n+import {\n+  some,\n+  Umi,\n+  transactionBuilder,\n+  publicKey,\n+  TransactionBuilder,\n+  none,\n+  AddressLookupTableInput,\n+  Transaction,\n+  Signer,\n+  sol,\n+  BlockhashWithExpiryBlockHeight,\n+} from \"@metaplex-foundation/umi\";\n+import { GuardReturn } from \"./checkerHelper\";\n+import { Connection } from \"@solana/web3.js\";\n+import {\n+  setComputeUnitPrice,\n+  setComputeUnitLimit,\n+  transferSol,\n+} from \"@metaplex-foundation/mpl-toolbox\";\n+import { toWeb3JsTransaction } from \"@metaplex-foundation/umi-web3js-adapters\";\n+import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n+\n+// 保留 GuardButtonList 结构定义\n+export const GuardButtonList = {\n+  label: \"\",\n+  allowed: false,\n+  minting: undefined,\n+  loadingText: undefined,\n+  reason: undefined,\n+  maxAmount: 0,\n+  mintAmount: undefined,\n+  header: \"\",\n+  mintText: \"\",\n+  buttonLabel: \"\",\n+  startTime: BigInt(0),\n+  endTime: BigInt(0),\n+  tooltip: undefined,\n+};\n+\n+export const chooseGuardToUse = (\n+  guard,\n+  candyGuard\n+) => {\n+  let guardGroup = candyGuard?.groups.find(\n+    (item) => item.label === guard.label\n+  );\n+  if (guardGroup) {\n+    return guardGroup;\n+  }\n+\n+  if (candyGuard != null) {\n+    return {\n+      label: \"default\",\n+      guards: candyGuard.guards,\n+    };\n+  }\n+\n+  console.error(\"No guards defined! No minting possible.\");\n+  return {\n+    label: \"default\",\n+    guards: undefined,\n+  };\n+};\n+\n+export const mintArgsBuilder = (\n+  candyMachine,\n+  guardToUse,\n+  ownedTokens\n+) => {\n+  const guards = guardToUse.guards;\n+  let ruleset = undefined;\n+  if (candyMachine.ruleSet.__option === \"Some\") {\n+    ruleset = candyMachine.ruleSet.value;\n+  }\n+\n+  let mintArgs: Partial<DefaultGuardSetMintArgs> = {};\n+  if (guards.allocation.__option === \"Some\") {\n+    mintArgs.allocation = some({ id: guards.allocation.value.id });\n+  }\n+\n+  if (guards.allowList.__option === \"Some\") {\n+    const allowlist = allowLists.get(guardToUse.label);\n+    if (!allowlist) {\n+      console.error(`allowlist for guard ${guardToUse.label} not found!`);\n+    } else {\n+      mintArgs.allowList = some({ merkleRoot: getMerkleRoot(allowlist) });\n+    }\n+  }\n+\n+  if (guards.freezeSolPayment.__option === \"Some\") {\n+    mintArgs.freezeSolPayment = some({\n+      destination: guards.freezeSolPayment.value.destination,\n+    });\n+  }\n+\n+  if (guards.freezeTokenPayment.__option === \"Some\") {\n+    mintArgs.freezeTokenPayment = some({\n+      destinationAta: guards.freezeTokenPayment.value.destinationAta,\n+      mint: guards.freezeTokenPayment.value.mint,\n+      nftRuleSet: ruleset,\n+    });\n+  }\n+\n+  if (guards.gatekeeper.__option === \"Some\") {\n+    mintArgs.gatekeeper = some({\n+      expireOnUse: guards.gatekeeper.value.expireOnUse,\n+      gatekeeperNetwork: guards.gatekeeper.value.gatekeeperNetwork,\n+    });\n+  }\n+\n+  if (guards.mintLimit.__option === \"Some\") {\n+    mintArgs.mintLimit = some({ id: guards.mintLimit.value.id });\n+  }\n+\n+  if (guards.nftBurn.__option === \"Some\") {\n+    const requiredCollection = guards.nftBurn.value.requiredCollection;\n+    const nft = ownedTokens.find(\n+      (el) =>\n+        el.metadata.collection.__option === \"Some\" &&\n+        el.metadata.collection.value.key === requiredCollection\n+    );\n+    if (!nft) {\n+      console.error(\"no nft to burn found!\");\n+    } else {\n+      let tokenStandard = TokenStandard.NonFungible;\n+      let ruleSet = undefined;\n+      if (nft.metadata.tokenStandard.__option === \"Some\") {\n+        if (\n+          nft.metadata.tokenStandard.value ===\n+          TokenStandard.ProgrammableNonFungible\n+        ) {\n+          tokenStandard = TokenStandard.ProgrammableNonFungible;\n+          if (\n+            nft.metadata.programmableConfig.__option === \"Some\" &&\n+            nft.metadata.programmableConfig.value.ruleSet.__option === \"Some\"\n+          ) {\n+            ruleSet = nft.metadata.programmableConfig.value.ruleSet.value;\n+          }\n+        }\n+      }\n+      mintArgs.nftBurn = some({\n+        mint: nft.publicKey,\n+        requiredCollection,\n+        tokenStandard,\n+        ruleSet,\n+      });\n+    }\n+  }\n+\n+  if (guards.nftGate.__option === \"Some\") {\n+    const requiredCollection = guards.nftGate.value.requiredCollection;\n+    const nft = ownedTokens.find(\n+      (el) =>\n+        el.metadata.collection.__option === \"Some\" &&\n+        el.metadata.collection.value.key === requiredCollection\n+    );\n+    if (!nft) {\n+      console.error(\"no nft for tokenGate found!\");\n+    } else {\n+      let tokenStandard = TokenStandard.NonFungible;\n+      let ruleSet = undefined;\n+      if (nft.metadata.tokenStandard.__option === \"Some\") {\n+        if (\n+          nft.metadata.tokenStandard.value ===\n+          TokenStandard.ProgrammableNonFungible\n+        ) {\n+          tokenStandard = TokenStandard.ProgrammableNonFungible;\n+          if (\n+            nft.metadata.programmableConfig.__option === \"Some\" &&\n+            nft.metadata.programmableConfig.value.ruleSet.__option === \"Some\"\n+          ) {\n+            ruleSet = nft.metadata.programmableConfig.value.ruleSet.value;\n+          }\n+        }\n+      }\n+      mintArgs.nftGate = some({\n+        mint: nft.publicKey,\n+        requiredCollection,\n+        tokenStandard,\n+        ruleSet,\n+      });\n+    }\n+  }\n+\n+  if (guards.nftPayment.__option === \"Some\") {\n+    const requiredCollection = guards.nftPayment.value.requiredCollection;\n+    const nft = ownedTokens.find(\n+      (el) =>\n+        el.metadata.collection.__option === \"Some\" &&\n+        el.metadata.collection.value.key === requiredCollection\n+    );\n+    if (!nft) {\n+      console.error(\"no nft for tokenGate found!\");\n+    } else {\n+      let tokenStandard = TokenStandard.NonFungible;\n+      let ruleSet = undefined;\n+      if (nft.metadata.tokenStandard.__option === \"Some\") {\n+        if (\n+          nft.metadata.tokenStandard.value ===\n+          TokenStandard.ProgrammableNonFungible\n+        ) {\n+          tokenStandard = TokenStandard.ProgrammableNonFungible;\n+          if (\n+            nft.metadata.programmableConfig.__option === \"Some\" &&\n+            nft.metadata.programmableConfig.value.ruleSet.__option === \"Some\"\n+          ) {\n+            ruleSet = nft.metadata.programmableConfig.value.ruleSet.value;\n+          }\n+        }\n+      }\n+      mintArgs.nftPayment = some({\n+        destination: guards.nftPayment.value.destination,\n+        mint: nft.publicKey,\n+        requiredCollection,\n+        tokenStandard,\n+        ruleSet,\n+      });\n+    }\n+  }\n+\n+  if (guards.solPayment.__option === \"Some\") {\n+    mintArgs.solPayment = some({\n+      destination: guards.solPayment.value.destination,\n+    });\n+  }\n+\n+  if (guards.thirdPartySigner.__option === \"Some\") {\n+    console.error(\"not supported. you need a backend\");\n+  }\n+\n+  if (guards.token2022Payment.__option === \"Some\") {\n+    mintArgs.token2022Payment = some({\n+      destinationAta: guards.token2022Payment.value.destinationAta,\n+      mint: guards.token2022Payment.value.mint,\n+    });\n+  }\n+\n+  if (guards.tokenBurn.__option === \"Some\") {\n+    mintArgs.tokenBurn = some({ mint: guards.tokenBurn.value.mint });\n+  }\n+\n+  if (guards.tokenGate.__option === \"Some\") {\n+    mintArgs.tokenGate = some({ mint: guards.tokenGate.value.mint });\n+  }\n+\n+  if (guards.tokenPayment.__option === \"Some\") {\n+    mintArgs.tokenPayment = some({\n+      destinationAta: guards.tokenPayment.value.destinationAta,\n+      mint: guards.tokenPayment.value.mint,\n+    });\n+  }\n+  return mintArgs;\n+};\n+\n+// build route instruction for allowlist guard\n+export const routeBuilder = async (\n+  umi,\n+  guardToUse,\n+  candyMachine\n+) => {\n+  let tx2 = transactionBuilder();\n+\n+  if (guardToUse.guards.allowList.__option === \"Some\") {\n+    const allowlist = allowLists.get(guardToUse.label);\n+    if (!allowlist) {\n+      console.error(\"allowlist not found!\");\n+      return tx2;\n+    }\n+    const allowListProof = await safeFetchAllowListProofFromSeeds(umi, {\n+      candyGuard: candyMachine.mintAuthority,\n+      candyMachine: candyMachine.publicKey,\n+      merkleRoot: getMerkleRoot(allowlist),\n+      user: publicKey(umi.identity),\n+    });\n+    console.log(\"allowListProof\",allowListProof)\n+    if (allowListProof === null) {\n+      console.log(\"null\")\n+      tx2 = tx2.add(\n+        route(umi, {\n+          guard: \"allowList\",\n+          candyMachine: candyMachine.publicKey,\n+          candyGuard: candyMachine.mintAuthority,\n+          group:\n+            guardToUse.label === \"default\" ? none() : some(guardToUse.label),\n+          routeArgs: {\n+            path: \"proof\",\n+            merkleRoot: getMerkleRoot(allowlist),\n+            merkleProof: getMerkleProof(allowlist, publicKey(umi.identity)),\n+          },\n+        })\n+      );\n+    }\n+    return tx2;\n+  }\n+};\n+\n+// combine transactions. return TransactionBuilder[]\n+export const combineTransactions = (\n+  umi,\n+  txs,\n+  tables\n+) => {\n+  const returnArray = [];\n+  let builder = transactionBuilder();\n+\n+  // combine as many transactions as possible into one\n+  for (let i = 0; i <= txs.length - 1; i++) {\n+    const tx = txs[i];\n+    let oldBuilder = builder;\n+    builder = builder.add(tx);\n+\n+    if (!builder.fitsInOneTransaction(umi)) {\n+      oldBuilder = oldBuilder.setAddressLookupTables(tables);\n+      returnArray.push(oldBuilder);\n+      builder = new TransactionBuilder();\n+      builder = builder.add(tx);\n+    }\n+    if (i === txs.length - 1) {\n+      returnArray.push(builder);\n+    }\n+  }\n+  return returnArray;\n+};\n+\n+export const buildTx = (\n+  umi,\n+  candyMachine,\n+  candyGuard,\n+  nftMint,\n+  guardToUse,\n+  mintArgs,\n+  luts,\n+  latestBlockhash,\n+  units,\n+  buyBeer\n+) => {\n+  let tx = transactionBuilder().add(\n+    mintV2(umi, {\n+      candyMachine: candyMachine.publicKey,\n+      collectionMint: candyMachine.collectionMint,\n+      collectionUpdateAuthority: candyMachine.authority,\n+      nftMint,\n+      group: guardToUse.label === \"default\" ? none() : some(guardToUse.label),\n+      candyGuard: candyGuard.publicKey,\n+      mintArgs,\n+      tokenStandard: candyMachine.tokenStandard,\n+    })\n+  );\n+  if (buyBeer) {\n+    tx = tx.prepend(\n+      transferSol(umi, {\n+        destination: publicKey(\n+          \"BeeryDvghgcKPTUw3N3bdFDFFWhTWdWHnsLuVebgsGSD\"\n+        ),\n+        amount: sol(Number(0.005)),\n+      })\n+    );\n+  }\n+  tx = tx.prepend(setComputeUnitLimit(umi, { units }));\n+  tx = tx.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\n+  tx = tx.setAddressLookupTables(luts);\n+  tx = tx.setBlockhash(latestBlockhash);\n+  return tx.build(umi);\n+};\n+\n+// simulate CU based on Sammys gist https://gist.github.com/stegaBOB/7c0cdc916db4524dd9c285f9e4309475\n+export const getRequiredCU = async (umi, transaction) => {\n+  const defaultCU = 800_000;\n+  const web3tx = toWeb3JsTransaction(transaction);\n+  let connection = new Connection(umi.rpc.getEndpoint(), \"finalized\");\n+  const simulatedTx = await connection.simulateTransaction(web3tx, {\n+    replaceRecentBlockhash: true,\n+    sigVerify: false,\n+  });\n+  if (simulatedTx.value.err || !simulatedTx.value.unitsConsumed) {\n+    return defaultCU;\n+  }\n+  return simulatedTx.value.unitsConsumed * 1.2 || defaultCU;\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731240696631,
            "name": "Commit-0",
            "content": "import { allowLists } from \"@/allowlist\";\nimport {\n  CandyGuard,\n  CandyMachine,\n  GuardGroup,\n  DefaultGuardSet,\n  DefaultGuardSetMintArgs,\n  getMerkleRoot,\n  route,\n  getMerkleProof,\n  safeFetchAllowListProofFromSeeds,\n  mintV2,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport {\n  DigitalAssetWithToken,\n  TokenStandard,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport {\n  some,\n  Umi,\n  transactionBuilder,\n  publicKey,\n  TransactionBuilder,\n  none,\n  AddressLookupTableInput,\n  Transaction,\n  Signer,\n  sol,\n  BlockhashWithExpiryBlockHeight,\n} from \"@metaplex-foundation/umi\";\nimport { GuardReturn } from \"./checkerHelper\";\nimport { Connection } from \"@solana/web3.js\";\nimport {\n  setComputeUnitPrice,\n  setComputeUnitLimit,\n  transferSol,\n} from \"@metaplex-foundation/mpl-toolbox\";\nimport { toWeb3JsTransaction } from \"@metaplex-foundation/umi-web3js-adapters\";\nimport { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n\n// 保留 GuardButtonList 结构定义\nexport const GuardButtonList = {\n  label: \"\",\n  allowed: false,\n  minting: undefined,\n  loadingText: undefined,\n  reason: undefined,\n  maxAmount: 0,\n  mintAmount: undefined,\n  header: \"\",\n  mintText: \"\",\n  buttonLabel: \"\",\n  startTime: BigInt(0),\n  endTime: BigInt(0),\n  tooltip: undefined,\n};\n\nexport const chooseGuardToUse = (\n  guard,\n  candyGuard\n) => {\n  let guardGroup = candyGuard?.groups.find(\n    (item) => item.label === guard.label\n  );\n  if (guardGroup) {\n    return guardGroup;\n  }\n\n  if (candyGuard != null) {\n    return {\n      label: \"default\",\n      guards: candyGuard.guards,\n    };\n  }\n\n  console.error(\"No guards defined! No minting possible.\");\n  return {\n    label: \"default\",\n    guards: undefined,\n  };\n};\n\nexport const mintArgsBuilder = (\n  candyMachine,\n  guardToUse,\n  ownedTokens\n) => {\n  const guards = guardToUse.guards;\n  let ruleset = undefined;\n  if (candyMachine.ruleSet.__option === \"Some\") {\n    ruleset = candyMachine.ruleSet.value;\n  }\n\n  let mintArgs = {};\n  if (guards.allocation.__option === \"Some\") {\n    mintArgs.allocation = some({ id: guards.allocation.value.id });\n  }\n\n  if (guards.allowList.__option === \"Some\") {\n    const allowlist = allowLists.get(guardToUse.label);\n    if (!allowlist) {\n      console.error(`allowlist for guard ${guardToUse.label} not found!`);\n    } else {\n      mintArgs.allowList = some({ merkleRoot: getMerkleRoot(allowlist) });\n    }\n  }\n\n  if (guards.freezeSolPayment.__option === \"Some\") {\n    mintArgs.freezeSolPayment = some({\n      destination: guards.freezeSolPayment.value.destination,\n    });\n  }\n\n  if (guards.freezeTokenPayment.__option === \"Some\") {\n    mintArgs.freezeTokenPayment = some({\n      destinationAta: guards.freezeTokenPayment.value.destinationAta,\n      mint: guards.freezeTokenPayment.value.mint,\n      nftRuleSet: ruleset,\n    });\n  }\n\n  if (guards.gatekeeper.__option === \"Some\") {\n    mintArgs.gatekeeper = some({\n      expireOnUse: guards.gatekeeper.value.expireOnUse,\n      gatekeeperNetwork: guards.gatekeeper.value.gatekeeperNetwork,\n    });\n  }\n\n  if (guards.mintLimit.__option === \"Some\") {\n    mintArgs.mintLimit = some({ id: guards.mintLimit.value.id });\n  }\n\n  if (guards.nftBurn.__option === \"Some\") {\n    const requiredCollection = guards.nftBurn.value.requiredCollection;\n    const nft = ownedTokens.find(\n      (el) =>\n        el.metadata.collection.__option === \"Some\" &&\n        el.metadata.collection.value.key === requiredCollection\n    );\n    if (!nft) {\n      console.error(\"no nft to burn found!\");\n    } else {\n      let tokenStandard = TokenStandard.NonFungible;\n      let ruleSet = undefined;\n      if (nft.metadata.tokenStandard.__option === \"Some\") {\n        if (\n          nft.metadata.tokenStandard.value ===\n          TokenStandard.ProgrammableNonFungible\n        ) {\n          tokenStandard = TokenStandard.ProgrammableNonFungible;\n          if (\n            nft.metadata.programmableConfig.__option === \"Some\" &&\n            nft.metadata.programmableConfig.value.ruleSet.__option === \"Some\"\n          ) {\n            ruleSet = nft.metadata.programmableConfig.value.ruleSet.value;\n          }\n        }\n      }\n      mintArgs.nftBurn = some({\n        mint: nft.publicKey,\n        requiredCollection,\n        tokenStandard,\n        ruleSet,\n      });\n    }\n  }\n\n  if (guards.nftGate.__option === \"Some\") {\n    const requiredCollection = guards.nftGate.value.requiredCollection;\n    const nft = ownedTokens.find(\n      (el) =>\n        el.metadata.collection.__option === \"Some\" &&\n        el.metadata.collection.value.key === requiredCollection\n    );\n    if (!nft) {\n      console.error(\"no nft for tokenGate found!\");\n    } else {\n      let tokenStandard = TokenStandard.NonFungible;\n      let ruleSet = undefined;\n      if (nft.metadata.tokenStandard.__option === \"Some\") {\n        if (\n          nft.metadata.tokenStandard.value ===\n          TokenStandard.ProgrammableNonFungible\n        ) {\n          tokenStandard = TokenStandard.ProgrammableNonFungible;\n          if (\n            nft.metadata.programmableConfig.__option === \"Some\" &&\n            nft.metadata.programmableConfig.value.ruleSet.__option === \"Some\"\n          ) {\n            ruleSet = nft.metadata.programmableConfig.value.ruleSet.value;\n          }\n        }\n      }\n      mintArgs.nftGate = some({\n        mint: nft.publicKey,\n        requiredCollection,\n        tokenStandard,\n        ruleSet,\n      });\n    }\n  }\n\n  if (guards.nftPayment.__option === \"Some\") {\n    const requiredCollection = guards.nftPayment.value.requiredCollection;\n    const nft = ownedTokens.find(\n      (el) =>\n        el.metadata.collection.__option === \"Some\" &&\n        el.metadata.collection.value.key === requiredCollection\n    );\n    if (!nft) {\n      console.error(\"no nft for tokenGate found!\");\n    } else {\n      let tokenStandard = TokenStandard.NonFungible;\n      let ruleSet = undefined;\n      if (nft.metadata.tokenStandard.__option === \"Some\") {\n        if (\n          nft.metadata.tokenStandard.value ===\n          TokenStandard.ProgrammableNonFungible\n        ) {\n          tokenStandard = TokenStandard.ProgrammableNonFungible;\n          if (\n            nft.metadata.programmableConfig.__option === \"Some\" &&\n            nft.metadata.programmableConfig.value.ruleSet.__option === \"Some\"\n          ) {\n            ruleSet = nft.metadata.programmableConfig.value.ruleSet.value;\n          }\n        }\n      }\n      mintArgs.nftPayment = some({\n        destination: guards.nftPayment.value.destination,\n        mint: nft.publicKey,\n        requiredCollection,\n        tokenStandard,\n        ruleSet,\n      });\n    }\n  }\n\n  if (guards.solPayment.__option === \"Some\") {\n    mintArgs.solPayment = some({\n      destination: guards.solPayment.value.destination,\n    });\n  }\n\n  if (guards.thirdPartySigner.__option === \"Some\") {\n    console.error(\"not supported. you need a backend\");\n  }\n\n  if (guards.token2022Payment.__option === \"Some\") {\n    mintArgs.token2022Payment = some({\n      destinationAta: guards.token2022Payment.value.destinationAta,\n      mint: guards.token2022Payment.value.mint,\n    });\n  }\n\n  if (guards.tokenBurn.__option === \"Some\") {\n    mintArgs.tokenBurn = some({ mint: guards.tokenBurn.value.mint });\n  }\n\n  if (guards.tokenGate.__option === \"Some\") {\n    mintArgs.tokenGate = some({ mint: guards.tokenGate.value.mint });\n  }\n\n  if (guards.tokenPayment.__option === \"Some\") {\n    mintArgs.tokenPayment = some({\n      destinationAta: guards.tokenPayment.value.destinationAta,\n      mint: guards.tokenPayment.value.mint,\n    });\n  }\n  return mintArgs;\n};\n\n// build route instruction for allowlist guard\nexport const routeBuilder = async (\n  umi,\n  guardToUse,\n  candyMachine\n) => {\n  let tx2 = transactionBuilder();\n\n  if (guardToUse.guards.allowList.__option === \"Some\") {\n    const allowlist = allowLists.get(guardToUse.label);\n    if (!allowlist) {\n      console.error(\"allowlist not found!\");\n      return tx2;\n    }\n    const allowListProof = await safeFetchAllowListProofFromSeeds(umi, {\n      candyGuard: candyMachine.mintAuthority,\n      candyMachine: candyMachine.publicKey,\n      merkleRoot: getMerkleRoot(allowlist),\n      user: publicKey(umi.identity),\n    });\n    console.log(\"allowListProof\",allowListProof)\n    if (allowListProof === null) {\n      console.log(\"null\")\n      tx2 = tx2.add(\n        route(umi, {\n          guard: \"allowList\",\n          candyMachine: candyMachine.publicKey,\n          candyGuard: candyMachine.mintAuthority,\n          group:\n            guardToUse.label === \"default\" ? none() : some(guardToUse.label),\n          routeArgs: {\n            path: \"proof\",\n            merkleRoot: getMerkleRoot(allowlist),\n            merkleProof: getMerkleProof(allowlist, publicKey(umi.identity)),\n          },\n        })\n      );\n    }\n    return tx2;\n  }\n};\n\n// combine transactions. return TransactionBuilder[]\nexport const combineTransactions = (\n  umi,\n  txs,\n  tables\n) => {\n  const returnArray = [];\n  let builder = transactionBuilder();\n\n  // combine as many transactions as possible into one\n  for (let i = 0; i <= txs.length - 1; i++) {\n    const tx = txs[i];\n    let oldBuilder = builder;\n    builder = builder.add(tx);\n\n    if (!builder.fitsInOneTransaction(umi)) {\n      oldBuilder = oldBuilder.setAddressLookupTables(tables);\n      returnArray.push(oldBuilder);\n      builder = new TransactionBuilder();\n      builder = builder.add(tx);\n    }\n    if (i === txs.length - 1) {\n      returnArray.push(builder);\n    }\n  }\n  return returnArray;\n};\n\nexport const buildTx = (\n  umi,\n  candyMachine,\n  candyGuard,\n  nftMint,\n  guardToUse,\n  mintArgs,\n  luts,\n  latestBlockhash,\n  units,\n  buyBeer\n) => {\n  let tx = transactionBuilder().add(\n    mintV2(umi, {\n      candyMachine: candyMachine.publicKey,\n      collectionMint: candyMachine.collectionMint,\n      collectionUpdateAuthority: candyMachine.authority,\n      nftMint,\n      group: guardToUse.label === \"default\" ? none() : some(guardToUse.label),\n      candyGuard: candyGuard.publicKey,\n      mintArgs,\n      tokenStandard: candyMachine.tokenStandard,\n    })\n  );\n  if (buyBeer) {\n    tx = tx.prepend(\n      transferSol(umi, {\n        destination: publicKey(\n          \"BeeryDvghgcKPTUw3N3bdFDFFWhTWdWHnsLuVebgsGSD\"\n        ),\n        amount: sol(Number(0.005)),\n      })\n    );\n  }\n  tx = tx.prepend(setComputeUnitLimit(umi, { units }));\n  tx = tx.prepend(setComputeUnitPrice(umi, { microLamports: parseInt(process.env.NEXT_PUBLIC_MICROLAMPORTS ?? \"1001\") }));\n  tx = tx.setAddressLookupTables(luts);\n  tx = tx.setBlockhash(latestBlockhash);\n  return tx.build(umi);\n};\n\n// simulate CU based on Sammys gist https://gist.github.com/stegaBOB/7c0cdc916db4524dd9c285f9e4309475\nexport const getRequiredCU = async (umi, transaction) => {\n  const defaultCU = 800_000;\n  const web3tx = toWeb3JsTransaction(transaction);\n  let connection = new Connection(umi.rpc.getEndpoint(), \"finalized\");\n  const simulatedTx = await connection.simulateTransaction(web3tx, {\n    replaceRecentBlockhash: true,\n    sigVerify: false,\n  });\n  if (simulatedTx.value.err || !simulatedTx.value.unitsConsumed) {\n    return defaultCU;\n  }\n  return simulatedTx.value.unitsConsumed * 1.2 || defaultCU;\n};"
        }
    ]
}