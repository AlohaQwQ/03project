{
    "sourceFile": "pages/utils/checkAllowed.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1731239422894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731240009560,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,8 @@\n   checkTokensRequired,\n   checkSolBalanceRequired,\n   mintLimitChecker,\n   ownedNftChecker,\n-  GuardReturn,\n   allocationChecker,\n   calculateMintable,\n } from \"./checkerHelper\";\n import { allowLists } from \"./../allowlist\";\n@@ -43,27 +42,35 @@\n   fetchAllDigitalAssetWithTokenByOwner,\n } from \"@metaplex-foundation/mpl-token-metadata\";\n import { checkAtaValid } from \"./validateConfig\";\n \n+// 保留 GuardReturn 结构定义\n+export const GuardReturn = {\n+  label: \"\",\n+  allowed: false,\n+  minting: undefined,\n+  loadingText: undefined,\n+  reason: undefined,\n+  maxAmount: 0,\n+  mintAmount: undefined,\n+};\n+\n export const guardChecker = async (\n-  umi: Umi,\n-  candyGuard: CandyGuard,\n-  candyMachine: CandyMachine,\n-  solanaTime: bigint\n+  umi,\n+  candyGuard,\n+  candyMachine,\n+  solanaTime\n ) => {\n-  let guardReturn: GuardReturn[] = [];\n-  let ownedTokens: DigitalAssetWithToken[] = [];\n+  let guardReturn = []; // 移除类型定义\n+  let ownedTokens = [];\n+  \n   if (!candyGuard) {\n-    if (guardReturn.length === 0) {\n-      //guardReturn.push({ label: \"default\", allowed: false });\n-    }\n     return { guardReturn, ownedNfts: ownedTokens };\n   }\n \n-  let guardsToCheck: { label: string; guards: GuardSet }[] = candyGuard.groups;\n+  let guardsToCheck = candyGuard.groups;\n   guardsToCheck.push({ label: \"default\", guards: candyGuard.guards });\n \n-  //no wallet connected. return dummies\n   const dummyPublicKey = publicKey(\"11111111111111111111111111111111\");\n   if (\n     umi.identity.publicKey === dummyPublicKey ||\n     Number(candyMachine.data.itemsAvailable) - Number(candyMachine.itemsRedeemed) === 0\n@@ -78,14 +85,13 @@\n     }\n     return { guardReturn, ownedNfts: ownedTokens };\n   }\n \n-  if (candyMachine.authority === umi.identity.publicKey){\n+  if (candyMachine.authority === umi.identity.publicKey) {\n     checkAtaValid(umi, guardsToCheck);\n   }\n \n-\n-  let solBalance: SolAmount = sol(0);\n+  let solBalance = sol(0);\n   if (checkSolBalanceRequired(guardsToCheck)) {\n     try {\n       const account = await umi.rpc.getAccount(umi.identity.publicKey);\n       assertAccountExists(account);\n@@ -114,9 +120,9 @@\n     const singleGuard = eachGuard.guards;\n     let mintableAmount = Number(candyMachine.data.itemsAvailable) - Number(candyMachine.itemsRedeemed);\n \n     if (singleGuard.addressGate.__option === \"Some\") {\n-      const addressGate = singleGuard.addressGate as Some<AddressGate>;\n+      const addressGate = singleGuard.addressGate;\n       if (\n         !addressGateChecker(\n           umi.identity.publicKey,\n           publicKey(addressGate.value.address)\n@@ -161,10 +167,10 @@\n       }\n     }\n \n     if (singleGuard.endDate.__option === \"Some\") {\n-      const addressGate = singleGuard.endDate as Some<EndDate>;\n-      if (solanaTime > addressGate.value.date) {\n+      const endDate = singleGuard.endDate;\n+      if (solanaTime > endDate.value.date) {\n         guardReturn.push({\n           label: eachGuard.label,\n           allowed: false,\n           reason: \"Mint time is over!\",\n@@ -175,10 +181,9 @@\n       }\n     }\n \n     if (singleGuard.freezeSolPayment.__option === \"Some\") {\n-      const freezeSolPayment =\n-        singleGuard.freezeSolPayment as Some<FreezeSolPayment>;\n+      const freezeSolPayment = singleGuard.freezeSolPayment;\n       const payableAmount = solBalance.basisPoints / freezeSolPayment.value.lamports.basisPoints;\n       mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n \n       if (freezeSolPayment.value.lamports.basisPoints > solBalance.basisPoints) {\n@@ -210,10 +215,9 @@\n       }\n     }\n \n     if (singleGuard.freezeTokenPayment.__option === \"Some\") {\n-      const freezeTokenPayment =\n-        singleGuard.freezeTokenPayment as Some<FreezeTokenPayment>;\n+      const freezeTokenPayment = singleGuard.freezeTokenPayment;\n       const digitalAssetWithToken = ownedTokens?.find(\n         (el) => el.mint.publicKey === freezeTokenPayment.value.mint\n       );\n       if (\n@@ -234,9 +238,9 @@\n       }\n     }\n \n     if (singleGuard.nftBurn.__option === \"Some\") {\n-      const nftBurn = singleGuard.nftBurn as Some<NftBurn>;\n+      const nftBurn = singleGuard.nftBurn;\n       const payableAmount = await ownedNftChecker(ownedTokens, nftBurn.value.requiredCollection);\n       mintableAmount = calculateMintable(mintableAmount, payableAmount);\n       if (payableAmount === 0) {\n         guardReturn.push({\n@@ -250,23 +254,23 @@\n       }\n     }\n \n     if (singleGuard.nftGate.__option === \"Some\") {\n-      const nftGate = singleGuard.nftGate as Some<NftGate>;\n+      const nftGate = singleGuard.nftGate;\n       if (!ownedNftChecker(ownedTokens, nftGate.value.requiredCollection)) {\n         guardReturn.push({\n           label: eachGuard.label,\n           allowed: false,\n-          reason: \"No NFT of the requred held!\",\n+          reason: \"No NFT of the required held!\",\n           maxAmount: 0\n         });\n         console.info(`${eachGuard.label}: NftGate no NFT held!`);\n         continue;\n       }\n     }\n \n     if (singleGuard.nftPayment.__option === \"Some\") {\n-      const nftPayment = singleGuard.nftPayment as Some<NftPayment>;\n+      const nftPayment = singleGuard.nftPayment;\n       const payableAmount = await ownedNftChecker(ownedTokens, nftPayment.value.requiredCollection);\n       mintableAmount = calculateMintable(mintableAmount, payableAmount);\n       if (payableAmount === 0) {\n         guardReturn.push({\n@@ -280,9 +284,9 @@\n       }\n     }\n \n     if (singleGuard.redeemedAmount.__option === \"Some\") {\n-      const redeemedAmount = singleGuard.redeemedAmount as Some<RedeemedAmount>;\n+      const redeemedAmount = singleGuard.redeemedAmount;\n       const payableAmount = redeemedAmount.value.maximum - candyMachine.itemsRedeemed;\n \n       mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n       if (redeemedAmount.value.maximum >= candyMachine.itemsRedeemed) {\n@@ -299,9 +303,9 @@\n       }\n     }\n \n     if (singleGuard.solPayment.__option === \"Some\") {\n-      const solPayment = singleGuard.solPayment as Some<SolPayment>;\n+      const solPayment = singleGuard.solPayment;\n       let payableAmount = 0;\n       if (solPayment.value.lamports.basisPoints !== BigInt(0)) {\n         payableAmount = Number(solBalance.basisPoints) / Number(solPayment.value.lamports.basisPoints);\n       }\n@@ -319,24 +323,23 @@\n       }\n     }\n \n     if (singleGuard.startDate.__option === \"Some\") {\n-      const startDate = singleGuard.startDate as Some<StartDate>;\n+      const startDate = singleGuard.startDate;\n       if (solanaTime < startDate.value.date) {\n         guardReturn.push({\n           label: eachGuard.label,\n           allowed: false,\n           reason: \"StartDate not reached!\",\n           maxAmount: 0\n         });\n         console.info(`${eachGuard.label} StartDate not reached!`);\n-\n         continue;\n       }\n     }\n \n     if (singleGuard.tokenBurn.__option === \"Some\") {\n-      const tokenBurn = singleGuard.tokenBurn as Some<TokenBurn>;\n+      const tokenBurn = singleGuard.tokenBurn;\n       const digitalAssetWithToken = ownedTokens?.find(\n         (el) => el.mint.publicKey === tokenBurn.value.mint\n       );\n       if (\n@@ -356,9 +359,9 @@\n       mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n     }\n \n     if (singleGuard.tokenGate.__option === \"Some\") {\n-      const tokenGate = singleGuard.tokenGate as Some<TokenGate>;\n+      const tokenGate = singleGuard.tokenGate;\n       const digitalAssetWithToken = ownedTokens?.find(\n         (el) => el.mint.publicKey === tokenGate.value.mint\n       );\n       if (\n@@ -376,9 +379,9 @@\n       }\n     }\n \n     if (singleGuard.tokenPayment.__option === \"Some\") {\n-      const tokenPayment = singleGuard.tokenPayment as Some<TokenPayment>;\n+      const tokenPayment = singleGuard.tokenPayment;\n       const digitalAssetWithToken = ownedTokens?.find(\n         (el) => el.mint.publicKey === tokenPayment.value.mint\n       );\n       if (\n@@ -395,14 +398,12 @@\n         continue;\n       }\n       const payableAmount = tokenPayment.value.amount / digitalAssetWithToken.token.amount;\n       mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n-\n     }\n \n     if (singleGuard.token2022Payment.__option === \"Some\") {\n-      const token2022Payment =\n-        singleGuard.token2022Payment as Some<TokenPayment>;\n+      const token2022Payment = singleGuard.token2022Payment;\n       const digitalAssetWithToken = ownedTokens?.find(\n         (el) => el.mint.publicKey === token2022Payment.value.mint\n       );\n       if (\n@@ -419,10 +420,10 @@\n         continue;\n       }\n       const payableAmount = token2022Payment.value.amount / digitalAssetWithToken.token.amount;\n       mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n+    }\n \n-    }\n     guardReturn.push({ label: eachGuard.label, allowed: true, maxAmount: mintableAmount });\n   }\n   return { guardReturn, ownedTokens };\n-};\n+};\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731239422894,
            "name": "Commit-0",
            "content": "import {\n  AddressGate,\n  Allocation,\n  CandyGuard,\n  CandyMachine,\n  EndDate,\n  FreezeSolPayment,\n  FreezeTokenPayment,\n  GuardSet,\n  NftBurn,\n  NftGate,\n  NftPayment,\n  RedeemedAmount,\n  SolPayment,\n  StartDate,\n  TokenBurn,\n  TokenGate,\n  TokenPayment,\n  getMerkleRoot,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport {\n  SolAmount,\n  Some,\n  Umi,\n  assertAccountExists,\n  publicKey,\n  sol,\n} from \"@metaplex-foundation/umi\";\nimport {\n  addressGateChecker,\n  allowlistChecker,\n  checkTokensRequired,\n  checkSolBalanceRequired,\n  mintLimitChecker,\n  ownedNftChecker,\n  GuardReturn,\n  allocationChecker,\n  calculateMintable,\n} from \"./checkerHelper\";\nimport { allowLists } from \"./../allowlist\";\nimport {\n  DigitalAssetWithToken,\n  fetchAllDigitalAssetWithTokenByOwner,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport { checkAtaValid } from \"./validateConfig\";\n\nexport const guardChecker = async (\n  umi: Umi,\n  candyGuard: CandyGuard,\n  candyMachine: CandyMachine,\n  solanaTime: bigint\n) => {\n  let guardReturn: GuardReturn[] = [];\n  let ownedTokens: DigitalAssetWithToken[] = [];\n  if (!candyGuard) {\n    if (guardReturn.length === 0) {\n      //guardReturn.push({ label: \"default\", allowed: false });\n    }\n    return { guardReturn, ownedNfts: ownedTokens };\n  }\n\n  let guardsToCheck: { label: string; guards: GuardSet }[] = candyGuard.groups;\n  guardsToCheck.push({ label: \"default\", guards: candyGuard.guards });\n\n  //no wallet connected. return dummies\n  const dummyPublicKey = publicKey(\"11111111111111111111111111111111\");\n  if (\n    umi.identity.publicKey === dummyPublicKey ||\n    Number(candyMachine.data.itemsAvailable) - Number(candyMachine.itemsRedeemed) === 0\n  ) {\n    for (const eachGuard of guardsToCheck) {\n      guardReturn.push({\n        label: eachGuard.label,\n        allowed: false,\n        reason: \"Please connect your wallet to mint\",\n        maxAmount: 0\n      });\n    }\n    return { guardReturn, ownedNfts: ownedTokens };\n  }\n\n  if (candyMachine.authority === umi.identity.publicKey){\n    checkAtaValid(umi, guardsToCheck);\n  }\n\n\n  let solBalance: SolAmount = sol(0);\n  if (checkSolBalanceRequired(guardsToCheck)) {\n    try {\n      const account = await umi.rpc.getAccount(umi.identity.publicKey);\n      assertAccountExists(account);\n      solBalance = account.lamports;\n    } catch (e) {\n      for (const eachGuard of guardsToCheck) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Wallet does not exist. Do you have SOL?\",\n          maxAmount: 0\n        });\n      }\n      return { guardReturn, ownedNfts: ownedTokens };\n    }\n  }\n\n  if (checkTokensRequired(guardsToCheck)) {\n    ownedTokens = await fetchAllDigitalAssetWithTokenByOwner(\n      umi,\n      umi.identity.publicKey\n    );\n  }\n\n  for (const eachGuard of guardsToCheck) {\n    const singleGuard = eachGuard.guards;\n    let mintableAmount = Number(candyMachine.data.itemsAvailable) - Number(candyMachine.itemsRedeemed);\n\n    if (singleGuard.addressGate.__option === \"Some\") {\n      const addressGate = singleGuard.addressGate as Some<AddressGate>;\n      if (\n        !addressGateChecker(\n          umi.identity.publicKey,\n          publicKey(addressGate.value.address)\n        )\n      ) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"AddressGate: Wrong Address\",\n          maxAmount: 0\n        });\n        continue;\n      }\n    }\n\n    if (singleGuard.allocation.__option === \"Some\") {\n      const allocatedAmount = await allocationChecker(umi, candyMachine, eachGuard);\n      mintableAmount = calculateMintable(mintableAmount, allocatedAmount);\n\n      if (allocatedAmount < 1) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Allocation of this guard reached\",\n          maxAmount: 0\n        });\n        console.info(`Guard ${eachGuard.label}; allocation reached`);\n        continue;\n      }\n    }\n\n    if (singleGuard.allowList.__option === \"Some\") {\n      if (!allowlistChecker(allowLists, umi, eachGuard.label)) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Wallet not allowlisted\",\n          maxAmount: 0\n        });\n        console.info(`Guard ${eachGuard.label} wallet not allowlisted!`);\n        continue;\n      }\n    }\n\n    if (singleGuard.endDate.__option === \"Some\") {\n      const addressGate = singleGuard.endDate as Some<EndDate>;\n      if (solanaTime > addressGate.value.date) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Mint time is over!\",\n          maxAmount: 0\n        });\n        console.info(`Guard ${eachGuard.label}; endDate reached!`);\n        continue;\n      }\n    }\n\n    if (singleGuard.freezeSolPayment.__option === \"Some\") {\n      const freezeSolPayment =\n        singleGuard.freezeSolPayment as Some<FreezeSolPayment>;\n      const payableAmount = solBalance.basisPoints / freezeSolPayment.value.lamports.basisPoints;\n      mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n\n      if (freezeSolPayment.value.lamports.basisPoints > solBalance.basisPoints) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough SOL\",\n          maxAmount: 0\n        });\n        console.info(\n          `Guard ${eachGuard.label}; freezeSolPayment: not enough SOL`\n        );\n        continue;\n      }\n    }\n\n    if (singleGuard.mintLimit.__option === \"Some\") {\n      const amount = await mintLimitChecker(umi, candyMachine, eachGuard);\n      mintableAmount = calculateMintable(mintableAmount, amount);\n      if (amount < 1) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Mint limit of this wallet reached\",\n          maxAmount: 0\n        });\n        console.info(`Guard ${eachGuard.label}; mintLimit reached`);\n        continue;\n      }\n    }\n\n    if (singleGuard.freezeTokenPayment.__option === \"Some\") {\n      const freezeTokenPayment =\n        singleGuard.freezeTokenPayment as Some<FreezeTokenPayment>;\n      const digitalAssetWithToken = ownedTokens?.find(\n        (el) => el.mint.publicKey === freezeTokenPayment.value.mint\n      );\n      if (\n        !digitalAssetWithToken ||\n        digitalAssetWithToken.token.amount >= freezeTokenPayment.value.amount\n      ) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough tokens!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label}: Token Balance too low !`);\n        continue;\n      } else {\n        const payableAmount = freezeTokenPayment.value.amount / digitalAssetWithToken.token.amount;\n        mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n      }\n    }\n\n    if (singleGuard.nftBurn.__option === \"Some\") {\n      const nftBurn = singleGuard.nftBurn as Some<NftBurn>;\n      const payableAmount = await ownedNftChecker(ownedTokens, nftBurn.value.requiredCollection);\n      mintableAmount = calculateMintable(mintableAmount, payableAmount);\n      if (payableAmount === 0) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"No NFT to burn!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label}: No Nft to burn!`);\n        continue;\n      }\n    }\n\n    if (singleGuard.nftGate.__option === \"Some\") {\n      const nftGate = singleGuard.nftGate as Some<NftGate>;\n      if (!ownedNftChecker(ownedTokens, nftGate.value.requiredCollection)) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"No NFT of the requred held!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label}: NftGate no NFT held!`);\n        continue;\n      }\n    }\n\n    if (singleGuard.nftPayment.__option === \"Some\") {\n      const nftPayment = singleGuard.nftPayment as Some<NftPayment>;\n      const payableAmount = await ownedNftChecker(ownedTokens, nftPayment.value.requiredCollection);\n      mintableAmount = calculateMintable(mintableAmount, payableAmount);\n      if (payableAmount === 0) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"No NFT to pay with!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label}: nftPayment no NFT to pay with`);\n        continue;\n      }\n    }\n\n    if (singleGuard.redeemedAmount.__option === \"Some\") {\n      const redeemedAmount = singleGuard.redeemedAmount as Some<RedeemedAmount>;\n      const payableAmount = redeemedAmount.value.maximum - candyMachine.itemsRedeemed;\n\n      mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n      if (redeemedAmount.value.maximum >= candyMachine.itemsRedeemed) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Too many NFTs redeemed!\",\n          maxAmount: 0\n        });\n        console.info(\n          `${eachGuard.label}: redeemedAmount Too many NFTs redeemed!`\n        );\n        continue;\n      }\n    }\n\n    if (singleGuard.solPayment.__option === \"Some\") {\n      const solPayment = singleGuard.solPayment as Some<SolPayment>;\n      let payableAmount = 0;\n      if (solPayment.value.lamports.basisPoints !== BigInt(0)) {\n        payableAmount = Number(solBalance.basisPoints) / Number(solPayment.value.lamports.basisPoints);\n      }\n      mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n\n      if (solPayment.value.lamports.basisPoints > solBalance.basisPoints) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough SOL!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label} SolPayment not enough SOL!`);\n        continue;\n      }\n    }\n\n    if (singleGuard.startDate.__option === \"Some\") {\n      const startDate = singleGuard.startDate as Some<StartDate>;\n      if (solanaTime < startDate.value.date) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"StartDate not reached!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label} StartDate not reached!`);\n\n        continue;\n      }\n    }\n\n    if (singleGuard.tokenBurn.__option === \"Some\") {\n      const tokenBurn = singleGuard.tokenBurn as Some<TokenBurn>;\n      const digitalAssetWithToken = ownedTokens?.find(\n        (el) => el.mint.publicKey === tokenBurn.value.mint\n      );\n      if (\n        !digitalAssetWithToken ||\n        digitalAssetWithToken.token.amount < tokenBurn.value.amount\n      ) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough tokens!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label} tokenBurn not enough tokens!`);\n        continue;\n      }\n      const payableAmount = tokenBurn.value.amount / digitalAssetWithToken.token.amount;\n      mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n    }\n\n    if (singleGuard.tokenGate.__option === \"Some\") {\n      const tokenGate = singleGuard.tokenGate as Some<TokenGate>;\n      const digitalAssetWithToken = ownedTokens?.find(\n        (el) => el.mint.publicKey === tokenGate.value.mint\n      );\n      if (\n        !digitalAssetWithToken ||\n        digitalAssetWithToken.token.amount < tokenGate.value.amount\n      ) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough tokens!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label} tokenGate not enough tokens!`);\n        continue;\n      }\n    }\n\n    if (singleGuard.tokenPayment.__option === \"Some\") {\n      const tokenPayment = singleGuard.tokenPayment as Some<TokenPayment>;\n      const digitalAssetWithToken = ownedTokens?.find(\n        (el) => el.mint.publicKey === tokenPayment.value.mint\n      );\n      if (\n        !digitalAssetWithToken ||\n        digitalAssetWithToken.token.amount < tokenPayment.value.amount\n      ) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough tokens!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label} tokenPayment not enough tokens!`);\n        continue;\n      }\n      const payableAmount = tokenPayment.value.amount / digitalAssetWithToken.token.amount;\n      mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n\n    }\n\n    if (singleGuard.token2022Payment.__option === \"Some\") {\n      const token2022Payment =\n        singleGuard.token2022Payment as Some<TokenPayment>;\n      const digitalAssetWithToken = ownedTokens?.find(\n        (el) => el.mint.publicKey === token2022Payment.value.mint\n      );\n      if (\n        !digitalAssetWithToken ||\n        digitalAssetWithToken.token.amount < token2022Payment.value.amount\n      ) {\n        guardReturn.push({\n          label: eachGuard.label,\n          allowed: false,\n          reason: \"Not enough tokens!\",\n          maxAmount: 0\n        });\n        console.info(`${eachGuard.label} token2022Payment not enough tokens!`);\n        continue;\n      }\n      const payableAmount = token2022Payment.value.amount / digitalAssetWithToken.token.amount;\n      mintableAmount = calculateMintable(mintableAmount, Number(payableAmount));\n\n    }\n    guardReturn.push({ label: eachGuard.label, allowed: true, maxAmount: mintableAmount });\n  }\n  return { guardReturn, ownedTokens };\n};\n"
        }
    ]
}