{
    "sourceFile": "pages/utils/createLutForCandyGuard.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1731240356273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731240431044,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,9 +40,10 @@\n ) => {\n   const addresses = await getLutAddressesForCandyMachineAndGuard(\n     umi,\n     candyMachine,\n-    candyGuard\n+    candyGuard,\n+    lutAuthority\n   );\n \n   return createLut(umi, {\n     recentSlot,\n"
                }
            ],
            "date": 1731240356273,
            "name": "Commit-0",
            "content": "import {\n  CandyGuard,\n  CandyMachine,\n  findAllocationTrackerPda,\n  findCandyMachineAuthorityPda,\n  getMplCandyMachineCoreProgramId,\n  safeFetchCandyGuard,\n  safeFetchMintCounterFromSeeds,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport {\n  MetadataDelegateRole,\n  findCollectionAuthorityRecordPda,\n  findMasterEditionPda,\n  findMetadataDelegateRecordPda,\n  findMetadataPda,\n  getMplTokenMetadataProgramId,\n} from \"@metaplex-foundation/mpl-token-metadata\";\nimport {\n  createLut,\n  getSplAssociatedTokenProgramId,\n  getSplTokenProgramId,\n  getSysvar,\n} from \"@metaplex-foundation/mpl-toolbox\";\nimport {\n  AddressLookupTableInput,\n  PublicKey,\n  Signer,\n  TransactionBuilder,\n  Umi,\n  publicKey,\n  uniquePublicKeys,\n} from \"@metaplex-foundation/umi\";\n\nexport const createLutForCandyMachineAndGuard = async (\n  umi,\n  recentSlot,\n  candyMachine,\n  candyGuard,\n  lutAuthority\n) => {\n  const addresses = await getLutAddressesForCandyMachineAndGuard(\n    umi,\n    candyMachine,\n    candyGuard\n  );\n\n  return createLut(umi, {\n    recentSlot,\n    addresses,\n    authority: lutAuthority,\n  });\n};\n\nexport const getLutAddressesForCandyMachineAndGuard = async (\n  umi,\n  candyMachine,\n  candyGuard,\n  collectionUpdateAuthority\n) => {\n  if (!umi.identity.publicKey) {\n    return [];\n  }\n  const { mintAuthority, collectionMint } = candyMachine;\n  collectionUpdateAuthority = umi.identity.publicKey;\n  if (!collectionUpdateAuthority) {\n    return [];\n  }\n  const collectionAuthorityPda = candyMachine.authority;\n  safeFetchCandyGuard(umi, candyMachine.mintAuthority);\n  const [delegateRecordV2] = findMetadataDelegateRecordPda(umi, {\n    mint: collectionMint,\n    delegateRole: MetadataDelegateRole.Collection,\n    updateAuthority: collectionUpdateAuthority,\n    delegate: collectionAuthorityPda,\n  });\n  const guardKeys = [];\n\n  // async iterate through all candyGuard groups and add all guards to guardKeys\n  for (const group of candyGuard.groups) {\n    if (group.guards.addressGate.__option === \"Some\") {\n      guardKeys.push(group.guards.addressGate.value.address);\n    }\n    if (group.guards.allocation.__option === \"Some\") {\n      guardKeys.push(\n        publicKey(\n          findAllocationTrackerPda(umi, {\n            candyGuard: candyGuard.publicKey,\n            candyMachine: candyMachine.publicKey,\n            id: group.guards.allocation.value.id,\n          })\n        )\n      );\n    }\n    if (group.guards.freezeSolPayment.__option === \"Some\") {\n      guardKeys.push(group.guards.freezeSolPayment.value.destination);\n    }\n    if (group.guards.freezeTokenPayment.__option === \"Some\") {\n      guardKeys.push(group.guards.freezeTokenPayment.value.destinationAta);\n      guardKeys.push(group.guards.freezeTokenPayment.value.mint);\n    }\n    if (group.guards.mintLimit.__option === \"Some\") {\n      const mintLimitCounter = await safeFetchMintCounterFromSeeds(umi, {\n        id: group.guards.mintLimit.value.id,\n        user: umi.identity.publicKey,\n        candyMachine: candyMachine.publicKey,\n        candyGuard: candyGuard.publicKey,\n      });\n      if (mintLimitCounter?.publicKey) {\n        guardKeys.push(mintLimitCounter.publicKey);\n      }\n    }\n    if (group.guards.nftBurn.__option === \"Some\") {\n      guardKeys.push(group.guards.nftBurn.value.requiredCollection);\n    }\n    if (group.guards.nftGate.__option === \"Some\") {\n      guardKeys.push(group.guards.nftGate.value.requiredCollection);\n    }\n    if (group.guards.nftPayment.__option === \"Some\") {\n      guardKeys.push(group.guards.nftPayment.value.requiredCollection);\n    }\n    if (group.guards.programGate.__option === \"Some\") {\n      // push the array content from group.guards.programGate.value.additional into guardKeys\n      group.guards.programGate.value.additional.forEach((programGate) => {\n        guardKeys.push(programGate);\n      });\n    }\n    if (group.guards.solPayment.__option === \"Some\") {\n      guardKeys.push(group.guards.solPayment.value.destination);\n    }\n    if (group.guards.token2022Payment.__option === \"Some\") {\n      guardKeys.push(group.guards.token2022Payment.value.destinationAta);\n      guardKeys.push(group.guards.token2022Payment.value.mint);\n    }\n    if (group.guards.tokenBurn.__option === \"Some\") {\n      guardKeys.push(group.guards.tokenBurn.value.mint);\n    }\n    if (group.guards.tokenGate.__option === \"Some\") {\n      guardKeys.push(group.guards.tokenGate.value.mint);\n    }\n    if (group.guards.tokenPayment.__option === \"Some\") {\n      guardKeys.push(group.guards.tokenPayment.value.mint);\n      guardKeys.push(group.guards.tokenPayment.value.destinationAta);\n    }\n  }\n\n  // Add collection Authority PDA\n  guardKeys.push(\n    publicKey(\n      findCollectionAuthorityRecordPda(umi, {\n        mint: collectionMint,\n        collectionAuthority: umi.identity.publicKey,\n      })\n    )\n  );\n  const [collectionAuthorityRecord] = findCollectionAuthorityRecordPda(umi, {\n    mint: collectionMint,\n    collectionAuthority: umi.identity.publicKey,\n  });\n\n  return uniquePublicKeys([\n    candyMachine.publicKey,\n    mintAuthority,\n    collectionMint,\n    findMetadataPda(umi, { mint: collectionMint })[0],\n    findMasterEditionPda(umi, { mint: collectionMint })[0],\n    collectionUpdateAuthority,\n    findCandyMachineAuthorityPda(umi, {\n      candyMachine: candyMachine.publicKey,\n    })[0],\n    delegateRecordV2,\n    getSysvar(\"instructions\"),\n    getSysvar(\"slotHashes\"),\n    getMplCandyMachineCoreProgramId(umi),\n    getMplTokenMetadataProgramId(umi),\n    getSplTokenProgramId(umi),\n    getSplAssociatedTokenProgramId(umi),\n    ...guardKeys,\n    publicKey(\"BeeryDvghgcKPTUw3N3bdFDFFWhTWdWHnsLuVebgsGSD\"),\n    collectionAuthorityRecord,\n  ]);\n};"
        }
    ]
}