{
    "sourceFile": "pages/utils/checkerHelper.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1731235880212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1731236566274,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,195 +19,18 @@\n } from \"@metaplex-foundation/umi\";\n import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n \n+// 保留 GuardReturn 接口定义\n+export const GuardReturn = {\n+  label: \"\",\n+  allowed: false,\n+  minting: undefined,\n+  loadingText: undefined,\n+  reason: undefined,\n+  maxAmount: 0,\n+  mintAmount: undefined,\n+};\n+\n export const addressGateChecker = (wallet, address) => {\n   return wallet === address;\n-};\n-\n-export const allocationChecker = async (\n-  umi,\n-  candyMachine,\n-  guard\n-) => {\n-  const allocation = guard.guards.allocation;\n-\n-  try {\n-    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n-      id: allocation.value.id,\n-      candyMachine: candyMachine.publicKey,\n-      candyGuard: candyMachine.mintAuthority,\n-    });\n-\n-    if (mintCounter) {\n-      return allocation.value.limit - mintCounter.count;\n-    } else {\n-      // no allocation mint Counter found - not created yet\n-      notification.error({\n-        message: \"Allocation Guard not Initialized!\",\n-        description: \"Minting will fail!\",\n-        duration: 9,\n-      });\n-      return allocation.value.limit;\n-    }\n-\n-  } catch (error) {\n-    console.error(`AllocationChecker: ${error}`);\n-    return 0;\n-  }\n-};\n-\n-export const solBalanceChecker = (\n-  solBalance,\n-  solAmount\n-) => {\n-  return solAmount <= solBalance;\n-};\n-\n-export const tokenBalanceChecker = async (\n-  umi,\n-  tokenAmount,\n-  tokenMint\n-) => {\n-  const ata = findAssociatedTokenPda(umi, {\n-    mint: tokenMint,\n-    owner: umi.identity.publicKey,\n-  });\n-\n-  const balance = await fetchToken(umi, umi.identity.publicKey);\n-\n-  return Number(balance.amount) >= Number(tokenAmount);\n-};\n-\n-export const mintLimitChecker = async (\n-  umi,\n-  candyMachine,\n-  guard\n-) => {\n-  const mintLimit = guard.guards.mintLimit;\n-\n-  //not minted yet\n-  try {\n-    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n-      id: mintLimit.value.id,\n-      user: umi.identity.publicKey,\n-      candyMachine: candyMachine.publicKey,\n-      candyGuard: candyMachine.mintAuthority,\n-    });\n-\n-    if (mintCounter) {\n-      return mintLimit.value.limit - mintCounter.count;\n-    } else {\n-      // no mintlimit counter found. Possibly the first mint\n-      return mintLimit.value.limit;\n-    }\n-  } catch (error) {\n-    console.error(`mintLimitChecker: ${error}`);\n-    return 0;\n-  }\n-};\n-\n-export const ownedNftChecker = async (\n-  ownedNfts,\n-  requiredCollection\n-) => {\n-  const count = ownedNfts.filter(\n-    (el) =>\n-      el.metadata.collection.__option === \"Some\" &&\n-      el.metadata.collection.value.key === requiredCollection &&\n-      el.metadata.collection.value.verified === true\n-  ).length;\n-  return count;\n-};\n-\n-export const allowlistChecker = (\n-  allowLists,\n-  umi,\n-  guardlabel\n-) => {\n-  if (!allowLists.has(guardlabel)) {\n-    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n-    return false;\n-  }\n-  if (\n-    !allowLists\n-      .get(guardlabel)\n-      ?.includes(publicKey(umi.identity.publicKey))\n-  ) {\n-    return false;\n-  }\n-  return true;\n-};\n-\n-export const getSolanaTime = async (umi) => {\n-  const slot = await umi.rpc.getSlot();\n-\n-  let solanaTime = await umi.rpc.getBlockTime(slot);\n-\n-  if (!solanaTime) solanaTime = BigInt(0);\n-  return solanaTime;\n-};\n-\n-export const checkDateRequired = (\n-  guards\n-) => {\n-  for (const guard of guards) {\n-    if (guard.guards.startDate || guard.guards.endDate) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-};\n-\n-export const checkSolBalanceRequired = (\n-  guards\n-) => {\n-  let solBalanceRequired = false;\n-  guards.forEach((guard) => {\n-    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n-      solBalanceRequired = true;\n-    }\n-  });\n-\n-  return solBalanceRequired;\n-};\n-\n-export const checkTokensRequired = (\n-  guards\n-) => {\n-  let nftBalanceRequired = false;\n-  guards.forEach((guard) => {\n-    if (\n-      guard.guards.nftBurn ||\n-      guard.guards.nftGate ||\n-      guard.guards.nftPayment\n-    ) {\n-      nftBalanceRequired = true;\n-    }\n-  });\n-\n-  return nftBalanceRequired;\n-};\n-\n-export const calculateMintable = (\n-  mintableAmount,\n-  newAmount\n-) => {\n-  if (mintableAmount > newAmount){\n-    mintableAmount = newAmount;\n-  }\n-\n-  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n-  let maxmintamount = 0;\n-  try {\n-    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n-  } catch (e){\n-    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n-    return mintableAmount;\n-  }\n-  if (mintableAmount > maxmintamount){\n-    mintableAmount = maxmintamount;\n-  }\n-\n-  return mintableAmount;\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731236574790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,20 +17,224 @@\n   Umi,\n   publicKey,\n } from \"@metaplex-foundation/umi\";\n import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n-import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n+import { createStandaloneToast } from \"@chakra-ui/react\";\n \n-// 保留 GuardReturn 接口定义\n-export const GuardReturn = {\n-  label: \"\",\n-  allowed: false,\n-  minting: undefined,\n-  loadingText: undefined,\n-  reason: undefined,\n-  maxAmount: 0,\n-  mintAmount: undefined,\n+export interface GuardReturn {\n+  label: string;\n+  allowed: boolean;\n+  minting?: boolean;\n\\ No newline at end of file\n+  loadingText?: string;\n+  reason?: string;\n+  maxAmount: number;\n+  mintAmount?: number;\n+}\n+\n+export const addressGateChecker = (wallet: PublicKey, address: PublicKey) => {\n+  if (wallet != address) {\n+    return false;\n+  }\n+  return true;\n };\n \n-export const addressGateChecker = (wallet, address) => {\n-  return wallet === address;\n-};\n+export const allocationChecker = async (\n+  umi: Umi,\n+  candyMachine: CandyMachine,\n+  guard: {\n+    label: string;\n+    guards: GuardSet;\n+}\n+) => {\n+  const allocation = guard.guards.allocation as Some<Allocation>;\n+\n+  try {\n+    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n+      id: allocation.value.id,\n+      candyMachine: candyMachine.publicKey,\n+      candyGuard: candyMachine.mintAuthority,\n+    });\n+\n+    if (mintCounter) {\n+      return allocation.value.limit - mintCounter.count;\n+    } else {\n+      // no allocation mint Counter found - not created yet\n+      createStandaloneToast().toast({\n+        title: \"Allocation Guard not Initialized!\",\n+        description: \"Minting will fail!\",\n+        status: \"error\",\n+        duration: 900,\n+        isClosable: true,\n+      });\n+      return allocation.value.limit;\n+    }\n+\n+  } catch (error) {\n+    console.error(`AllocationChecker: ${error}`);\n+    return 0;\n+  }\n+};\n+\n+export const solBalanceChecker = (\n+  solBalance: SolAmount,\n+  solAmount: SolAmount\n+) => {\n+  if (solAmount > solBalance) {\n+    return false;\n+  }\n+  return true;\n+};\n+\n+export const tokenBalanceChecker = async (\n+  umi: Umi,\n+  tokenAmount: bigint,\n+  tokenMint: PublicKey\n+) => {\n+  const ata = findAssociatedTokenPda(umi, {\n+    mint: tokenMint,\n+    owner: umi.identity.publicKey,\n+  });\n+\n+  const balance = await fetchToken(umi, umi.identity.publicKey);\n+\n+  if (Number(balance.amount) < Number(tokenAmount)) {\n+    return false;\n+  }\n+  return true;\n+};\n+\n+export const mintLimitChecker = async (\n+  umi: Umi,\n+  candyMachine: CandyMachine,\n+  guard: {\n+    label: string;\n+    guards: GuardSet;\n+}\n+) => {\n+  const mintLimit = guard.guards.mintLimit as Some<MintLimit>;\n+\n+  //not minted yet\n+  try {\n+    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n+      id: mintLimit.value.id,\n+      user: umi.identity.publicKey,\n+      candyMachine: candyMachine.publicKey,\n+      candyGuard: candyMachine.mintAuthority,\n+    });\n+\n+    if (mintCounter) {\n+      return mintLimit.value.limit - mintCounter.count;\n+    } else {\n+      // no mintlimit counter found. Possibly the first mint\n+      return mintLimit.value.limit;\n+    }\n+  } catch (error) {\n+    console.error(`mintLimitChecker: ${error}`);\n+    return 0;\n+  }\n+};\n+\n+export const ownedNftChecker = async (\n+  ownedNfts: DigitalAssetWithToken[],\n+  requiredCollection: PublicKey\n+) => {\n+  const count = ownedNfts.filter(\n+    (el) =>\n+      el.metadata.collection.__option === \"Some\" &&\n+      el.metadata.collection.value.key === requiredCollection &&\n+      el.metadata.collection.value.verified === true\n+  ).length;\n+  return count;\n+};\n+\n+export const allowlistChecker = (\n+  allowLists: Map<string, string[]>,\n+  umi: Umi,\n+  guardlabel: string\n+) => {\n+  if (!allowLists.has(guardlabel)) {\n+    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n+    return false;\n+  }\n+  if (\n+    !allowLists\n+      .get(guardlabel)\n+      ?.includes(publicKey(umi.identity.publicKey))\n+  ) {\n+    return false;\n+  }\n+  return true;\n+};\n+\n+export const getSolanaTime = async (umi: Umi) => {\n+  const slot = await umi.rpc.getSlot();\n+\n+  let solanaTime = await umi.rpc.getBlockTime(slot);\n+\n+  if (!solanaTime) solanaTime = BigInt(0);\n+  return solanaTime;\n+};\n+\n+export const checkDateRequired = (\n+  guards: { label: string; guards: GuardSet }[]\n+) => {\n+  for (const guard of guards) {\n+    if (guard.guards.startDate || guard.guards.endDate) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+};\n+\n+export const checkSolBalanceRequired = (\n+  guards: { label: string; guards: GuardSet }[]\n+) => {\n+  let solBalanceRequired: boolean = false;\n+  guards.forEach((guard) => {\n+    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n+      solBalanceRequired = true;\n+    }\n+  });\n+\n+  return solBalanceRequired;\n+};\n+\n+export const checkTokensRequired = (\n+  guards: { label: string; guards: GuardSet }[]\n+) => {\n+  let nftBalanceRequired: boolean = false;\n+  guards.forEach((guard) => {\n+    if (\n+      guard.guards.nftBurn ||\n+      guard.guards.nftGate ||\n+      guard.guards.nftPayment\n+    ) {\n+      nftBalanceRequired = true;\n+    }\n+  });\n+\n+  return nftBalanceRequired;\n+};\n+\n+export const calculateMintable = (\n+  mintableAmount: number,\n+  newAmount: number\n+) => {\n+  if (mintableAmount > newAmount){\n+    mintableAmount = newAmount;\n+  }\n+\n+  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n+  let maxmintamount = 0;\n+  try {\n+    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n+  } catch (e){\n+    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n+    return mintableAmount;\n+  }\n+  if (mintableAmount > maxmintamount){\n+    mintableAmount = maxmintamount;\n+  }\n+\n+  return mintableAmount;\n+};\n"
                },
                {
                    "date": 1731236580913,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,224 +17,20 @@\n   Umi,\n   publicKey,\n } from \"@metaplex-foundation/umi\";\n import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n-import { createStandaloneToast } from \"@chakra-ui/react\";\n+import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n \n-export interface GuardReturn {\n-  label: string;\n-  allowed: boolean;\n-  minting?: boolean;\n-  loadingText?: string;\n-  reason?: string;\n-  maxAmount: number;\n-  mintAmount?: number;\n-}\n-\n-export const addressGateChecker = (wallet: PublicKey, address: PublicKey) => {\n-  if (wallet != address) {\n-    return false;\n-  }\n-  return true;\n+// 保留 GuardReturn 接口定义\n+export const GuardReturn = {\n+  label: \"\",\n+  allowed: false,\n+  minting: undefined,\n+  loadingText: undefined,\n+  reason: undefined,\n+  maxAmount: 0,\n+  mintAmount: undefined,\n };\n \n-export const allocationChecker = async (\n-  umi: Umi,\n-  candyMachine: CandyMachine,\n-  guard: {\n-    label: string;\n-    guards: GuardSet;\n-}\n-) => {\n-  const allocation = guard.guards.allocation as Some<Allocation>;\n-\n-  try {\n-    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n-      id: allocation.value.id,\n-      candyMachine: candyMachine.publicKey,\n-      candyGuard: candyMachine.mintAuthority,\n-    });\n-\n-    if (mintCounter) {\n-      return allocation.value.limit - mintCounter.count;\n-    } else {\n-      // no allocation mint Counter found - not created yet\n-      createStandaloneToast().toast({\n-        title: \"Allocation Guard not Initialized!\",\n-        description: \"Minting will fail!\",\n-        status: \"error\",\n-        duration: 900,\n-        isClosable: true,\n-      });\n-      return allocation.value.limit;\n-    }\n-\n-  } catch (error) {\n-    console.error(`AllocationChecker: ${error}`);\n-    return 0;\n-  }\n-};\n-\n-export const solBalanceChecker = (\n-  solBalance: SolAmount,\n-  solAmount: SolAmount\n-) => {\n-  if (solAmount > solBalance) {\n-    return false;\n-  }\n-  return true;\n-};\n-\n-export const tokenBalanceChecker = async (\n-  umi: Umi,\n-  tokenAmount: bigint,\n-  tokenMint: PublicKey\n-) => {\n-  const ata = findAssociatedTokenPda(umi, {\n-    mint: tokenMint,\n-    owner: umi.identity.publicKey,\n-  });\n-\n-  const balance = await fetchToken(umi, umi.identity.publicKey);\n-\n-  if (Number(balance.amount) < Number(tokenAmount)) {\n-    return false;\n-  }\n-  return true;\n-};\n-\n-export const mintLimitChecker = async (\n-  umi: Umi,\n-  candyMachine: CandyMachine,\n-  guard: {\n-    label: string;\n-    guards: GuardSet;\n-}\n-) => {\n-  const mintLimit = guard.guards.mintLimit as Some<MintLimit>;\n-\n-  //not minted yet\n-  try {\n-    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n-      id: mintLimit.value.id,\n-      user: umi.identity.publicKey,\n-      candyMachine: candyMachine.publicKey,\n-      candyGuard: candyMachine.mintAuthority,\n-    });\n-\n-    if (mintCounter) {\n-      return mintLimit.value.limit - mintCounter.count;\n-    } else {\n-      // no mintlimit counter found. Possibly the first mint\n-      return mintLimit.value.limit;\n-    }\n-  } catch (error) {\n-    console.error(`mintLimitChecker: ${error}`);\n-    return 0;\n-  }\n-};\n-\n-export const ownedNftChecker = async (\n-  ownedNfts: DigitalAssetWithToken[],\n-  requiredCollection: PublicKey\n-) => {\n-  const count = ownedNfts.filter(\n-    (el) =>\n-      el.metadata.collection.__option === \"Some\" &&\n-      el.metadata.collection.value.key === requiredCollection &&\n-      el.metadata.collection.value.verified === true\n-  ).length;\n-  return count;\n-};\n-\n-export const allowlistChecker = (\n-  allowLists: Map<string, string[]>,\n-  umi: Umi,\n-  guardlabel: string\n-) => {\n-  if (!allowLists.has(guardlabel)) {\n-    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n-    return false;\n-  }\n-  if (\n-    !allowLists\n-      .get(guardlabel)\n-      ?.includes(publicKey(umi.identity.publicKey))\n-  ) {\n-    return false;\n-  }\n-  return true;\n-};\n-\n-export const getSolanaTime = async (umi: Umi) => {\n-  const slot = await umi.rpc.getSlot();\n-\n-  let solanaTime = await umi.rpc.getBlockTime(slot);\n-\n-  if (!solanaTime) solanaTime = BigInt(0);\n-  return solanaTime;\n-};\n-\n-export const checkDateRequired = (\n-  guards: { label: string; guards: GuardSet }[]\n-) => {\n-  for (const guard of guards) {\n-    if (guard.guards.startDate || guard.guards.endDate) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-};\n-\n-export const checkSolBalanceRequired = (\n-  guards: { label: string; guards: GuardSet }[]\n-) => {\n-  let solBalanceRequired: boolean = false;\n-  guards.forEach((guard) => {\n-    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n-      solBalanceRequired = true;\n-    }\n-  });\n-\n-  return solBalanceRequired;\n-};\n-\n-export const checkTokensRequired = (\n-  guards: { label: string; guards: GuardSet }[]\n-) => {\n-  let nftBalanceRequired: boolean = false;\n-  guards.forEach((guard) => {\n-    if (\n-      guard.guards.nftBurn ||\n-      guard.guards.nftGate ||\n-      guard.guards.nftPayment\n-    ) {\n-      nftBalanceRequired = true;\n-    }\n-  });\n-\n-  return nftBalanceRequired;\n-};\n-\n-export const calculateMintable = (\n-  mintableAmount: number,\n-  newAmount: number\n-) => {\n-  if (mintableAmount > newAmount){\n-    mintableAmount = newAmount;\n-  }\n-\n-  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n-  let maxmintamount = 0;\n-  try {\n-    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n-  } catch (e){\n-    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n-    return mintableAmount;\n-  }\n-  if (mintableAmount > maxmintamount){\n-    mintableAmount = maxmintamount;\n-  }\n-\n-  return mintableAmount;\n+export const addressGateChecker = (wallet, address) => {\n+  return wallet === address;\n };\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731239054495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,224 @@\n+import {\n+  Allocation,\n+  CandyMachine,\n+  GuardSet,\n+  MintLimit,\n+  safeFetchAllocationTrackerFromSeeds,\n+  safeFetchMintCounterFromSeeds,\n+} from \"@metaplex-foundation/mpl-candy-machine\";\n+import {\n+  fetchToken,\n+  findAssociatedTokenPda,\n+} from \"@metaplex-foundation/mpl-toolbox\";\n+import {\n+  PublicKey,\n+  SolAmount,\n+  Some,\n+  Umi,\n+  publicKey,\n+} from \"@metaplex-foundation/umi\";\n+import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n+import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n+\n+// 保留 GuardReturn 接口定义\n+export const GuardReturn = {\n+  label: \"\",\n+  allowed: false,\n+  minting: undefined,\n+  loadingText: undefined,\n+  reason: undefined,\n+  maxAmount: 0,\n+  mintAmount: undefined,\n+};\n+\n+export const addressGateChecker = (wallet, address) => {\n+  return wallet === address;\n+};\n+\n+export const allocationChecker = async (\n+  umi,\n+  candyMachine,\n+  guard\n+) => {\n+  const allocation = guard.guards.allocation;\n+\n+  try {\n+    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n+      id: allocation.value.id,\n+      candyMachine: candyMachine.publicKey,\n+      candyGuard: candyMachine.mintAuthority,\n+    });\n+\n+    if (mintCounter) {\n+      return allocation.value.limit - mintCounter.count;\n+    } else {\n+      // no allocation mint Counter found - not created yet\n+      notification.error({\n+        message: \"Allocation Guard not Initialized!\",\n+        description: \"Minting will fail!\",\n+        duration: 9,\n+      });\n+      return allocation.value.limit;\n+    }\n+\n+  } catch (error) {\n+    console.error(`AllocationChecker: ${error}`);\n+    return 0;\n+  }\n+};\n+\n+export const solBalanceChecker = (\n+  solBalance,\n+  solAmount\n+) => {\n+  return solAmount <= solBalance;\n+};\n+\n+export const tokenBalanceChecker = async (\n+  umi,\n+  tokenAmount,\n+  tokenMint\n+) => {\n+  const ata = findAssociatedTokenPda(umi, {\n+    mint: tokenMint,\n+    owner: umi.identity.publicKey,\n+  });\n+\n+  const balance = await fetchToken(umi, umi.identity.publicKey);\n+\n+  return Number(balance.amount) >= Number(tokenAmount);\n+};\n+\n+export const mintLimitChecker = async (\n+  umi,\n+  candyMachine,\n+  guard\n+) => {\n+  const mintLimit = guard.guards.mintLimit;\n+\n+  //not minted yet\n+  try {\n+    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n+      id: mintLimit.value.id,\n+      user: umi.identity.publicKey,\n+      candyMachine: candyMachine.publicKey,\n+      candyGuard: candyMachine.mintAuthority,\n+    });\n+\n+    if (mintCounter) {\n+      return mintLimit.value.limit - mintCounter.count;\n+    } else {\n+      // no mintlimit counter found. Possibly the first mint\n+      return mintLimit.value.limit;\n+    }\n+  } catch (error) {\n+    console.error(`mintLimitChecker: ${error}`);\n+    return 0;\n+  }\n+};\n+\n+export const ownedNftChecker = async (\n+  ownedNfts,\n+  requiredCollection\n+) => {\n+  const count = ownedNfts.filter(\n+    (el) =>\n+      el.metadata.collection.__option === \"Some\" &&\n+      el.metadata.collection.value.key === requiredCollection &&\n+      el.metadata.collection.value.verified === true\n+  ).length;\n+  return count;\n+};\n+\n+export const allowlistChecker = (\n+  allowLists,\n+  umi,\n+  guardlabel\n+) => {\n+  if (!allowLists.has(guardlabel)) {\n+    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n+    return false;\n+  }\n+  if (\n+    !allowLists\n+      .get(guardlabel)\n+      ?.includes(publicKey(umi.identity.publicKey))\n+  ) {\n+    return false;\n+  }\n+  return true;\n+};\n+\n+export const getSolanaTime = async (umi) => {\n+  const slot = await umi.rpc.getSlot();\n+\n+  let solanaTime = await umi.rpc.getBlockTime(slot);\n+\n+  if (!solanaTime) solanaTime = BigInt(0);\n+  return solanaTime;\n+};\n+\n+export const checkDateRequired = (\n+  guards\n+) => {\n+  for (const guard of guards) {\n+    if (guard.guards.startDate || guard.guards.endDate) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+};\n+\n+export const checkSolBalanceRequired = (\n+  guards\n+) => {\n+  let solBalanceRequired = false;\n+  guards.forEach((guard) => {\n+    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n+      solBalanceRequired = true;\n+    }\n+  });\n+\n+  return solBalanceRequired;\n+};\n+\n+export const checkTokensRequired = (\n+  guards\n+) => {\n+  let nftBalanceRequired = false;\n+  guards.forEach((guard) => {\n+    if (\n+      guard.guards.nftBurn ||\n+      guard.guards.nftGate ||\n+      guard.guards.nftPayment\n+    ) {\n+      nftBalanceRequired = true;\n+    }\n+  });\n+\n+  return nftBalanceRequired;\n+};\n+\n+export const calculateMintable = (\n+  mintableAmount,\n+  newAmount\n+) => {\n+  if (mintableAmount > newAmount){\n+    mintableAmount = newAmount;\n+  }\n+\n+  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n+  let maxmintamount = 0;\n+  try {\n+    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n+  } catch (e){\n+    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n+    return mintableAmount;\n+  }\n+  if (mintableAmount > maxmintamount){\n+    mintableAmount = maxmintamount;\n+  }\n+\n+  return mintableAmount;\n+};\n"
                },
                {
                    "date": 1731239382759,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n } from \"@metaplex-foundation/umi\";\n import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n \n-// 保留 GuardReturn 接口定义\n+// 保留 GuardReturn 结构定义\n export const GuardReturn = {\n   label: \"\",\n   allowed: false,\n   minting: undefined,\n@@ -220,5 +220,5 @@\n     mintableAmount = maxmintamount;\n   }\n \n   return mintableAmount;\n-};\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731239389889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,9 +19,9 @@\n } from \"@metaplex-foundation/umi\";\n import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n \n-// 保留 GuardReturn 结构定义\n+// 保留 GuardReturn 接口定义\n export const GuardReturn = {\n   label: \"\",\n   allowed: false,\n   minting: undefined,\n@@ -221,40 +221,4 @@\n   }\n \n   return mintableAmount;\n };\n-import {\n-  Allocation,\n-  CandyMachine,\n-  GuardSet,\n-  MintLimit,\n-  safeFetchAllocationTrackerFromSeeds,\n-  safeFetchMintCounterFromSeeds,\n-} from \"@metaplex-foundation/mpl-candy-machine\";\n-import {\n-  fetchToken,\n-  findAssociatedTokenPda,\n-} from \"@metaplex-foundation/mpl-toolbox\";\n-import {\n-  PublicKey,\n-  SolAmount,\n-  Some,\n-  Umi,\n-  publicKey,\n-} from \"@metaplex-foundation/umi\";\n-import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n-import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n-\n-// 保留 GuardReturn 接口定义\n-export const GuardReturn = {\n-  label: \"\",\n-  allowed: false,\n-  minting: undefined,\n-  loadingText: undefined,\n-  reason: undefined,\n-  maxAmount: 0,\n-  mintAmount: undefined,\n-};\n-\n-export const addressGateChecker = (wallet, address) => {\n-  return wallet === address;\n-};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731239412004,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,224 @@\n+import {\n+  Allocation,\n+  CandyMachine,\n+  GuardSet,\n+  MintLimit,\n+  safeFetchAllocationTrackerFromSeeds,\n+  safeFetchMintCounterFromSeeds,\n+} from \"@metaplex-foundation/mpl-candy-machine\";\n+import {\n+  fetchToken,\n+  findAssociatedTokenPda,\n+} from \"@metaplex-foundation/mpl-toolbox\";\n+import {\n+  PublicKey,\n+  SolAmount,\n+  Some,\n+  Umi,\n+  publicKey,\n+} from \"@metaplex-foundation/umi\";\n+import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n+import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n+\n+// 保留 GuardReturn 结构定义\n+export const GuardReturn = {\n+  label: \"\",\n+  allowed: false,\n+  minting: undefined,\n+  loadingText: undefined,\n+  reason: undefined,\n+  maxAmount: 0,\n+  mintAmount: undefined,\n+};\n+\n+export const addressGateChecker = (wallet, address) => {\n+  return wallet === address;\n+};\n+\n+export const allocationChecker = async (\n+  umi,\n+  candyMachine,\n+  guard\n+) => {\n+  const allocation = guard.guards.allocation;\n+\n+  try {\n+    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n+      id: allocation.value.id,\n+      candyMachine: candyMachine.publicKey,\n+      candyGuard: candyMachine.mintAuthority,\n+    });\n+\n+    if (mintCounter) {\n+      return allocation.value.limit - mintCounter.count;\n+    } else {\n+      // no allocation mint Counter found - not created yet\n+      notification.error({\n+        message: \"Allocation Guard not Initialized!\",\n+        description: \"Minting will fail!\",\n+        duration: 9,\n+      });\n+      return allocation.value.limit;\n+    }\n+\n+  } catch (error) {\n+    console.error(`AllocationChecker: ${error}`);\n+    return 0;\n+  }\n+};\n+\n+export const solBalanceChecker = (\n+  solBalance,\n+  solAmount\n+) => {\n+  return solAmount <= solBalance;\n+};\n+\n+export const tokenBalanceChecker = async (\n+  umi,\n+  tokenAmount,\n+  tokenMint\n+) => {\n+  const ata = findAssociatedTokenPda(umi, {\n+    mint: tokenMint,\n+    owner: umi.identity.publicKey,\n+  });\n+\n+  const balance = await fetchToken(umi, umi.identity.publicKey);\n+\n+  return Number(balance.amount) >= Number(tokenAmount);\n+};\n+\n+export const mintLimitChecker = async (\n+  umi,\n+  candyMachine,\n+  guard\n+) => {\n+  const mintLimit = guard.guards.mintLimit;\n+\n+  //not minted yet\n+  try {\n+    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n+      id: mintLimit.value.id,\n+      user: umi.identity.publicKey,\n+      candyMachine: candyMachine.publicKey,\n+      candyGuard: candyMachine.mintAuthority,\n+    });\n+\n+    if (mintCounter) {\n+      return mintLimit.value.limit - mintCounter.count;\n+    } else {\n+      // no mintlimit counter found. Possibly the first mint\n+      return mintLimit.value.limit;\n+    }\n+  } catch (error) {\n+    console.error(`mintLimitChecker: ${error}`);\n+    return 0;\n+  }\n+};\n+\n+export const ownedNftChecker = async (\n+  ownedNfts,\n+  requiredCollection\n+) => {\n+  const count = ownedNfts.filter(\n+    (el) =>\n+      el.metadata.collection.__option === \"Some\" &&\n+      el.metadata.collection.value.key === requiredCollection &&\n+      el.metadata.collection.value.verified === true\n+  ).length;\n+  return count;\n+};\n+\n+export const allowlistChecker = (\n+  allowLists,\n+  umi,\n+  guardlabel\n+) => {\n+  if (!allowLists.has(guardlabel)) {\n+    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n+    return false;\n+  }\n+  if (\n+    !allowLists\n+      .get(guardlabel)\n+      ?.includes(publicKey(umi.identity.publicKey))\n+  ) {\n+    return false;\n+  }\n+  return true;\n+};\n+\n+export const getSolanaTime = async (umi) => {\n+  const slot = await umi.rpc.getSlot();\n+\n+  let solanaTime = await umi.rpc.getBlockTime(slot);\n+\n+  if (!solanaTime) solanaTime = BigInt(0);\n+  return solanaTime;\n+};\n+\n+export const checkDateRequired = (\n+  guards\n+) => {\n+  for (const guard of guards) {\n+    if (guard.guards.startDate || guard.guards.endDate) {\n+      return true;\n+    }\n+  }\n+\n+  return false;\n+};\n+\n+export const checkSolBalanceRequired = (\n+  guards\n+) => {\n+  let solBalanceRequired = false;\n+  guards.forEach((guard) => {\n+    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n+      solBalanceRequired = true;\n+    }\n+  });\n+\n+  return solBalanceRequired;\n+};\n+\n+export const checkTokensRequired = (\n+  guards\n+) => {\n+  let nftBalanceRequired = false;\n+  guards.forEach((guard) => {\n+    if (\n+      guard.guards.nftBurn ||\n+      guard.guards.nftGate ||\n+      guard.guards.nftPayment\n+    ) {\n+      nftBalanceRequired = true;\n+    }\n+  });\n+\n+  return nftBalanceRequired;\n+};\n+\n+export const calculateMintable = (\n+  mintableAmount,\n+  newAmount\n+) => {\n+  if (mintableAmount > newAmount){\n+    mintableAmount = newAmount;\n+  }\n+\n+  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n+  let maxmintamount = 0;\n+  try {\n+    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n+  } catch (e){\n+    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n+    return mintableAmount;\n+  }\n+  if (mintableAmount > maxmintamount){\n+    mintableAmount = maxmintamount;\n+  }\n+\n+  return mintableAmount;\n+};\n\\ No newline at end of file\n"
                },
                {
                    "date": 1731256956385,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -220,229 +220,5 @@\n     mintableAmount = maxmintamount;\n   }\n \n   return mintableAmount;\n-};\n-import {\n-  Allocation,\n-  CandyMachine,\n-  GuardSet,\n-  MintLimit,\n-  safeFetchAllocationTrackerFromSeeds,\n-  safeFetchMintCounterFromSeeds,\n-} from \"@metaplex-foundation/mpl-candy-machine\";\n-import {\n-  fetchToken,\n-  findAssociatedTokenPda,\n-} from \"@metaplex-foundation/mpl-toolbox\";\n-import {\n-  PublicKey,\n-  SolAmount,\n-  Some,\n-  Umi,\n-  publicKey,\n-} from \"@metaplex-foundation/umi\";\n-import { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\n-import { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n-\n-// 保留 GuardReturn 接口定义\n-export const GuardReturn = {\n-  label: \"\",\n-  allowed: false,\n-  minting: undefined,\n-  loadingText: undefined,\n-  reason: undefined,\n-  maxAmount: 0,\n-  mintAmount: undefined,\n-};\n-\n-export const addressGateChecker = (wallet, address) => {\n-  return wallet === address;\n-};\n-\n-export const allocationChecker = async (\n-  umi,\n-  candyMachine,\n-  guard\n-) => {\n-  const allocation = guard.guards.allocation;\n-\n-  try {\n-    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n-      id: allocation.value.id,\n-      candyMachine: candyMachine.publicKey,\n-      candyGuard: candyMachine.mintAuthority,\n-    });\n-\n-    if (mintCounter) {\n-      return allocation.value.limit - mintCounter.count;\n-    } else {\n-      // no allocation mint Counter found - not created yet\n-      notification.error({\n-        message: \"Allocation Guard not Initialized!\",\n-        description: \"Minting will fail!\",\n-        duration: 9,\n-      });\n-      return allocation.value.limit;\n-    }\n-\n-  } catch (error) {\n-    console.error(`AllocationChecker: ${error}`);\n-    return 0;\n-  }\n-};\n-\n-export const solBalanceChecker = (\n-  solBalance,\n-  solAmount\n-) => {\n-  return solAmount <= solBalance;\n-};\n-\n-export const tokenBalanceChecker = async (\n-  umi,\n-  tokenAmount,\n-  tokenMint\n-) => {\n-  const ata = findAssociatedTokenPda(umi, {\n-    mint: tokenMint,\n-    owner: umi.identity.publicKey,\n-  });\n-\n-  const balance = await fetchToken(umi, umi.identity.publicKey);\n-\n-  return Number(balance.amount) >= Number(tokenAmount);\n-};\n-\n-export const mintLimitChecker = async (\n-  umi,\n-  candyMachine,\n-  guard\n-) => {\n-  const mintLimit = guard.guards.mintLimit;\n-\n-  //not minted yet\n-  try {\n-    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n-      id: mintLimit.value.id,\n-      user: umi.identity.publicKey,\n-      candyMachine: candyMachine.publicKey,\n-      candyGuard: candyMachine.mintAuthority,\n-    });\n-\n-    if (mintCounter) {\n-      return mintLimit.value.limit - mintCounter.count;\n-    } else {\n-      // no mintlimit counter found. Possibly the first mint\n-      return mintLimit.value.limit;\n-    }\n-  } catch (error) {\n-    console.error(`mintLimitChecker: ${error}`);\n-    return 0;\n-  }\n-};\n-\n-export const ownedNftChecker = async (\n-  ownedNfts,\n-  requiredCollection\n-) => {\n-  const count = ownedNfts.filter(\n-    (el) =>\n-      el.metadata.collection.__option === \"Some\" &&\n-      el.metadata.collection.value.key === requiredCollection &&\n-      el.metadata.collection.value.verified === true\n-  ).length;\n-  return count;\n-};\n-\n-export const allowlistChecker = (\n-  allowLists,\n-  umi,\n-  guardlabel\n-) => {\n-  if (!allowLists.has(guardlabel)) {\n-    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n-    return false;\n-  }\n-  if (\n-    !allowLists\n-      .get(guardlabel)\n-      ?.includes(publicKey(umi.identity.publicKey))\n-  ) {\n-    return false;\n-  }\n-  return true;\n-};\n-\n-export const getSolanaTime = async (umi) => {\n-  const slot = await umi.rpc.getSlot();\n-\n-  let solanaTime = await umi.rpc.getBlockTime(slot);\n-\n-  if (!solanaTime) solanaTime = BigInt(0);\n-  return solanaTime;\n-};\n-\n-export const checkDateRequired = (\n-  guards\n-) => {\n-  for (const guard of guards) {\n-    if (guard.guards.startDate || guard.guards.endDate) {\n-      return true;\n-    }\n-  }\n-\n-  return false;\n-};\n-\n-export const checkSolBalanceRequired = (\n-  guards\n-) => {\n-  let solBalanceRequired = false;\n-  guards.forEach((guard) => {\n-    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n-      solBalanceRequired = true;\n-    }\n-  });\n-\n-  return solBalanceRequired;\n-};\n-\n-export const checkTokensRequired = (\n-  guards\n-) => {\n-  let nftBalanceRequired = false;\n-  guards.forEach((guard) => {\n-    if (\n-      guard.guards.nftBurn ||\n-      guard.guards.nftGate ||\n-      guard.guards.nftPayment\n-    ) {\n-      nftBalanceRequired = true;\n-    }\n-  });\n-\n-  return nftBalanceRequired;\n-};\n-\n-export const calculateMintable = (\n-  mintableAmount,\n-  newAmount\n-) => {\n-  if (mintableAmount > newAmount){\n-    mintableAmount = newAmount;\n-  }\n-\n-  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n-  let maxmintamount = 0;\n-  try {\n-    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n-  } catch (e){\n-    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n-    return mintableAmount;\n-  }\n-  if (mintableAmount > maxmintamount){\n-    mintableAmount = maxmintamount;\n-  }\n-\n-  return mintableAmount;\n };\n\\ No newline at end of file\n"
                }
            ],
            "date": 1731235880212,
            "name": "Commit-0",
            "content": "import {\n  Allocation,\n  CandyMachine,\n  GuardSet,\n  MintLimit,\n  safeFetchAllocationTrackerFromSeeds,\n  safeFetchMintCounterFromSeeds,\n} from \"@metaplex-foundation/mpl-candy-machine\";\nimport {\n  fetchToken,\n  findAssociatedTokenPda,\n} from \"@metaplex-foundation/mpl-toolbox\";\nimport {\n  PublicKey,\n  SolAmount,\n  Some,\n  Umi,\n  publicKey,\n} from \"@metaplex-foundation/umi\";\nimport { DigitalAssetWithToken } from \"@metaplex-foundation/mpl-token-metadata\";\nimport { notification } from \"antd\"; // 使用 Ant Design 的 notification 组件\n\nexport const addressGateChecker = (wallet, address) => {\n  return wallet === address;\n};\n\nexport const allocationChecker = async (\n  umi,\n  candyMachine,\n  guard\n) => {\n  const allocation = guard.guards.allocation;\n\n  try {\n    const mintCounter = await safeFetchAllocationTrackerFromSeeds(umi, {\n      id: allocation.value.id,\n      candyMachine: candyMachine.publicKey,\n      candyGuard: candyMachine.mintAuthority,\n    });\n\n    if (mintCounter) {\n      return allocation.value.limit - mintCounter.count;\n    } else {\n      // no allocation mint Counter found - not created yet\n      notification.error({\n        message: \"Allocation Guard not Initialized!\",\n        description: \"Minting will fail!\",\n        duration: 9,\n      });\n      return allocation.value.limit;\n    }\n\n  } catch (error) {\n    console.error(`AllocationChecker: ${error}`);\n    return 0;\n  }\n};\n\nexport const solBalanceChecker = (\n  solBalance,\n  solAmount\n) => {\n  return solAmount <= solBalance;\n};\n\nexport const tokenBalanceChecker = async (\n  umi,\n  tokenAmount,\n  tokenMint\n) => {\n  const ata = findAssociatedTokenPda(umi, {\n    mint: tokenMint,\n    owner: umi.identity.publicKey,\n  });\n\n  const balance = await fetchToken(umi, umi.identity.publicKey);\n\n  return Number(balance.amount) >= Number(tokenAmount);\n};\n\nexport const mintLimitChecker = async (\n  umi,\n  candyMachine,\n  guard\n) => {\n  const mintLimit = guard.guards.mintLimit;\n\n  //not minted yet\n  try {\n    const mintCounter = await safeFetchMintCounterFromSeeds(umi, {\n      id: mintLimit.value.id,\n      user: umi.identity.publicKey,\n      candyMachine: candyMachine.publicKey,\n      candyGuard: candyMachine.mintAuthority,\n    });\n\n    if (mintCounter) {\n      return mintLimit.value.limit - mintCounter.count;\n    } else {\n      // no mintlimit counter found. Possibly the first mint\n      return mintLimit.value.limit;\n    }\n  } catch (error) {\n    console.error(`mintLimitChecker: ${error}`);\n    return 0;\n  }\n};\n\nexport const ownedNftChecker = async (\n  ownedNfts,\n  requiredCollection\n) => {\n  const count = ownedNfts.filter(\n    (el) =>\n      el.metadata.collection.__option === \"Some\" &&\n      el.metadata.collection.value.key === requiredCollection &&\n      el.metadata.collection.value.verified === true\n  ).length;\n  return count;\n};\n\nexport const allowlistChecker = (\n  allowLists,\n  umi,\n  guardlabel\n) => {\n  if (!allowLists.has(guardlabel)) {\n    console.error(`Guard ${guardlabel}; allowlist missing from allowlist.tsx`);\n    return false;\n  }\n  if (\n    !allowLists\n      .get(guardlabel)\n      ?.includes(publicKey(umi.identity.publicKey))\n  ) {\n    return false;\n  }\n  return true;\n};\n\nexport const getSolanaTime = async (umi) => {\n  const slot = await umi.rpc.getSlot();\n\n  let solanaTime = await umi.rpc.getBlockTime(slot);\n\n  if (!solanaTime) solanaTime = BigInt(0);\n  return solanaTime;\n};\n\nexport const checkDateRequired = (\n  guards\n) => {\n  for (const guard of guards) {\n    if (guard.guards.startDate || guard.guards.endDate) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport const checkSolBalanceRequired = (\n  guards\n) => {\n  let solBalanceRequired = false;\n  guards.forEach((guard) => {\n    if (guard.guards.freezeSolPayment || guard.guards.solPayment) {\n      solBalanceRequired = true;\n    }\n  });\n\n  return solBalanceRequired;\n};\n\nexport const checkTokensRequired = (\n  guards\n) => {\n  let nftBalanceRequired = false;\n  guards.forEach((guard) => {\n    if (\n      guard.guards.nftBurn ||\n      guard.guards.nftGate ||\n      guard.guards.nftPayment\n    ) {\n      nftBalanceRequired = true;\n    }\n  });\n\n  return nftBalanceRequired;\n};\n\nexport const calculateMintable = (\n  mintableAmount,\n  newAmount\n) => {\n  if (mintableAmount > newAmount){\n    mintableAmount = newAmount;\n  }\n\n  if (!process.env.NEXT_PUBLIC_MAXMINTAMOUNT) return mintableAmount;\n  let maxmintamount = 0;\n  try {\n    maxmintamount = Number(process.env.NEXT_PUBLIC_MAXMINTAMOUNT)\n  } catch (e){\n    console.error('process.env.NEXT_PUBLIC_MAXMINTAMOUNT is not a number!', e)\n    return mintableAmount;\n  }\n  if (mintableAmount > maxmintamount){\n    mintableAmount = maxmintamount;\n  }\n\n  return mintableAmount;\n};"
        }
    ]
}